# 算法模板

## 快排

> 主要思想是分治。时间复杂度是nlogn
>
> 1、确定分界点，q[l], q[(l+r)/2], q[r] 随机
>
> 2、调整位置，使得左边的数据小于等于x，右边的数大于等于x。（x的位置不固定，满足规律即可）
>
> 3、递归处理左右两边的数

java

```java
private static void quick_sort(int[] q, int l, int r) {
    // 递归出口
    if (l >= r) {
        return;
    }

    int x = q[(l + r) >> 1], i = l - 1, j = r + 1;
    while (i < j) {
        do i ++ ; while(q[i] < x);
        do j -- ; while(q[j] > x);
        if (i < j){
            int t = q[i];
            q[i] = q[j];
            q[j] = t ;
        }
    }

    // 递归处理左右
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```

go

```go
package main

import (
    "fmt"
)

const N = 1e6 + 10

func main() {

    q := make([]int, N)
    var n int
    fmt.Scanf("%d", &n)

    for i := 0; i < n; i++ {
        fmt.Scanf("%d", &q[i])
    }

    quickSort(q, 0, n-1)

    for i := 0; i < n; i++ {
        fmt.Printf("%d ", q[i])
    }
}

func quickSort(q []int, l, r int) {
    //递归出口
    if l >= r {
        return
    }

    //中间值
    x := q[(l+r)>>1]
    //左右指针
    i, j := l-1, r+1
    for i < j {
        // do while 语法
        for {
            i++
            if q[i] >= x {
                break
            }
        }
        for {
            j--
            if q[j] <= x {
                break
            }
        }

        //交换值
        if i < j {
            q[i], q[j] = q[j], q[i]
        }
    }

    // 递归处理左右
    quickSort(q, l, j)
    quickSort(q, j+1, r)
}
```

## 归并

> 主要思想：分治。时间复杂度是nlogn
>
> 1、去一个中间值，确定分界点 [mid = (l + r) / 2]
>
> 2、递归排序left和right
>
> 3、最后再将两个数组合二为一

java

https://www.acwing.com/solution/content/158424/

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * @Author: yuluo
 * @CreateTime: 2022-11-05  19:43
 * @Description: 归并排序
 */

public class Main {

    private static final int N = (int) 1e6 + 10;

    static int n;
    static int[] array = new int[N];
    static int[] tmp = new int[N];
    
    public static void main(String[] args) throws IOException {

        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(bufferedReader.readLine());

        String[] s = bufferedReader.readLine().split(" ");

        for (int i = 0; i < s.length; i++) {
            array[i] = Integer.parseInt(s[i]);
        }

        mergeSort(array, 0, n - 1);

        for (int i = 0; i < n; i++) {
            System.out.print(array[i] + " ");
        }
    }
    
    private static void mergeSort(int[] q, int l, int r) {
        
        // 递归出口
        if (l >= r) {
            return;
        }
        
        int mid = l + r >> 1;
        
        mergeSort(q, l, mid);
        mergeSort(q, mid + 1, r);
        
        int k = 0, i = l, j = mid + 1;
        while (i <= mid && j <= r) {
            if (q[i] <= q[j]) {
                tmp[k ++] = q[i ++];
            } else {
                tmp[k ++] = q[j ++];
            }
        }
        
        while (i <= mid) {
            tmp[k ++] = q[i ++];
        }
        while (j <= r) {
            tmp[k ++] = q[j ++];
        }
        
        for (i = l, j = 0; i <= r; i ++, j ++) {
            q[i] = tmp[j];
        }
        
    } 

}
```

go

```go
package main

import "fmt"

const N = 1e6 + 10

func main() {
	var n int
	fmt.Scanf("%d", &n)

	q := make([]int, N)
	t := make([]int, n)

	for i := 0; i < n; i ++ {
		fmt.Scanf("%d", &q[i])
	}

	mergeSort(q, t, 0, n - 1)

	for i := 0; i < n; i ++ {
		fmt.Printf("%d ", q[i])
	}

}

func mergeSort(q, tmp []int, l, r int) {

	// 递归出口
	if l >= r { 
		return 
	}

	// 取中间值
	mid := l + (r-l)/2
	
	// 递归处理mid左右
	// 1. 处理左
	mergeSort(q, tmp, l, mid)
	// 2. 处理右
	mergeSort(q, tmp, mid+1, r)

	// 3. 合并数组
	// k 表示已经合并几个数，i和j表示指针
	k, i, j := 0, l, mid+1 
	for i <= mid && j <= r {
		if q[i] <= q[j] { 
			tmp[k] = q[i]
			k, i = k+1, i+1
		} else {
			tmp[k] = q[j]
			k, j = k+1, j+1
		}
	}

	// 判断左边是否已经访问完
	for i <= mid {
		// 没有访问完就继续加到序列中取
		tmp[k] = q[i] 
		k, i = k+1, i+1
	}
	
	// 同上
	for j <= r { 
		tmp[k] = q[j]
		k, j = k+1, j+1
	}

	// 放回到原数组中
	for i, j := l, 0; i <= r; i, j = i+1, j+1 {
		q[i] = tmp[j] 
	}
}
```

swap操作（异或操作）

```java
public static void swap(int a, int b) {
    a = a ^ b;	
	b = a ^ b;	
	a = a ^ b;
}
```

## 二分

> 本质是边界，（非单调性）。比如：找出一个数x在x的左边满足某个条件，右边不满足某个条件。

### 整数

模板

```java
/**
* 区间[r, r]被划分成[l, mid]和[mid + 1, r]时使用
*/
public static int bsearch_1(int l, int r) {
    while (l < r) {
        int mid = l + r >> 1;
        // check函数判断mid是否满足某个性质
        if (check(mid)) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
}

/**
* 区间[r, r]被划分成[l, mid - 1]和[mid, r]时使用
*/
public static int bsearch_1(int l, int r) {
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (check(mid)) {
            l = mid;
        } else {
            r = mid - 1;
        }
    }
    return l;
}
```

acwing 数的范围

java

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int N = 100010;
    static int[] a = new int[N];

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String[] s1 = in.readLine().split(" ");
        int n = Integer.parseInt(s1[0]);
        int q = Integer.parseInt(s1[1]);
        String[] s2 = in.readLine().split(" ");
        for(int i = 0; i < n; i ++) a[i] = Integer.parseInt(s2[i]);

        while(q -- > 0) {
            int k = Integer.parseInt(in.readLine());
            int l = 0, r = n - 1;
            while(l < r) {
                int mid = l + r >> 1;
                if(a[mid] >= k) r = mid;
                else l = mid + 1;
            }
            if(a[l] != k) System.out.println("-1 -1");
            else {
                int left = l;//此时l = r  所以left = l 或者r 都可以 哪个都行
                //System.out.println(l+" " );   后面在输出l
                l = 0;
                r = n - 1;
                while(l < r) {
                    int mid = l + r + 1 >> 1;
                    if(a[mid] <= k) l = mid;
                    else r = mid -1;
                }
                System.out.println(left + " " + l);
            }
        }
    }
}
```

go

```go
package main

import "fmt"

const N = 100010

var (
	n, m int
    q [N]int
)

func main() {
	fmt.Scanf("%d%d", &n, &m)
    for i := 0; i < n; i ++ {
        fmt.Scanf("%d", &q[i])
    }
    
    for ;m > 0; m -- {
        var x int
        fmt.Scanf("%d", &x)
        l, r := 0, n - 1
        for l < r {
            mid := (l + r) >> 1
            if q[mid] >= x {
      	    	r = mid
        	} else {
	            l = mid + 1
    	    }
        }
        if q[l] != x {
            fmt.Println("-1 -1" )
        } else {
            fmt.Print(l, " ")
            l, r := 0, n - 1
            for l < r {
                mid := (l + r + 1) >> 1
                if q[mid] <= x {
                    l = mid
                } else {
                    r = mid - 1
                }
            }
            
            fmt.Println(l)
        }
    }
}
```

### 浮点数

求一个数的平方根

```java
import java.util.Scanner;

/**
 * @Author: yuluo
 * @CreateTime: 2022-11-06  21:47
 * @Description: 浮点数二分
 */

public class Main {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        double n = Double.parseDouble(scanner.next());

 
        double l=-1000;
        double r=1000;

        // for (int i = 0; i < 100; i ++) {
        // 当使用while循环时，一般精度比题目要求的高出两位即可保证输出的正确性
        while (r - l > 1e-8) {
            double mid = (l + r) / 2;
            if (mid * mid * mid >= n) {
                r = mid;
            } else {
                l = mid;
            }
        }
        System.out.printf("%6f\n", l);
    }
}
```

go

```go
package main

import (
    "fmt"
    "math"
)

var x float64

func main() {
    fmt.Scanf("%f", &x)

    var l, r float64 = -10000, 10000
    for r-l > 1e-8 {
        mid := (l + r) / 2
        if math.Pow(mid, 3) >= x {
            r = mid
        } else {
            l = mid
        }
    }

    fmt.Printf("%.6f", l)
}
```

## 高精度

> C++ 有高精度问题，java和python不存在此问题

### 加法

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

/**
 * @Author: yuluo
 * @CreateTime: 2022-11-07  19:21
 * @Description: C++有精度问题，Java和python没有精度问题
 */

public class Main {

    static int N = 1000010;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s1 = br.readLine();
        String s2 = br.readLine();

        List<Integer> listA = new ArrayList<>(s1.length());
        List<Integer> listB = new ArrayList<>(s2.length());

        /*
        注意这里存储的时候，是个位数放第一个，好处理进位
         */
        for (int i = s1.length() - 1; i >=0 ; i --) {
            listA.add(s1.charAt(i) - '0');  // 减去一个偏移量，变成数字
        }

        for (int i = s2.length() - 1; i >= 0; i --) {
            listB.add(s2.charAt(i) - '0');
        }

        String res = sum(listA, listB);

        System.out.println(res);
    }

    /**
     * 模板
     * @param listA
     * @param listB
     * @return
     */
    private static String sum(List<Integer> listA, List<Integer> listB) {

        int[] a = new int[N + 10];

        int t = 0, i;
        for (i = 0; i < listA.size() || i < listB.size(); i ++) {
            if (i < listA.size()) {
                t += listA.get(i);
            }
            if (i < listB.size()) {
                t += listB.get(i);
            }
            a[i] = t % 10;
            t /= 10;
        }

        if (t > 0) {
            a[i] = t;
        }

        while(i >= 1 && a[i] == 0) i --;
        StringBuilder stb = new StringBuilder();
        for(int j = i; j >= 0; j --) {
            stb.append(a[j]);
        }
        return stb.toString();
    }

}

```

### 减法

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * @Author: yuluo
 * @CreateTime: 2022-11-07  19:21
 * @Description: C++有精度问题，Java和python没有精度问题
 */

public class Main {

    static int N = 1000010;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s1 = br.readLine();
        String s2 = br.readLine();

        List<Integer> listA = new ArrayList<>(s1.length());
        List<Integer> listB = new ArrayList<>(s2.length());

        /*
        注意这里存储的时候，是个位数放第一个，好处理进位
         */
        for (int i = s1.length() - 1; i >=0 ; i --) {
            listA.add(s1.charAt(i) - '0');  // 减去一个偏移量，变成数字
        }

        for (int i = s2.length() - 1; i >= 0; i --) {
            listB.add(s2.charAt(i) - '0');
        }

        // String res = sum(listA, listB);
        // System.out.println(res);

        // 减法
        process(listA, listB);
    }

    /**
     * 过渡一下减法过程
     * 分为两种情况 A > B 和 A < B
     * @param listA
     * @param listB
     * @return
     */
    private static void process(List<Integer> listA, List<Integer> listB) {
        String res = "";
        // 判断大小
        if (cmp(listA, listB)) {
            // 大于
            res = subtraction(listA, listB);
            System.out.println(res);
        } else {
            // 小于
            res = subtraction(listA, listB);
            System.out.print("-" + res);
        }
    }

    /**
     * 比较两个数的大小 A >= B
     */
    private static boolean cmp(List<Integer> listA, List<Integer> listB) {
        if (listA.size() != listB.size()) {
            return listA.size() > listB.size();
        }
        // 如果位数相同，从高位依次相比
        for (int i = 0; i < listA.size() - 1; i ++) {
            if (!Objects.equals(listA.get(i), listB.get(i))) {
                return listA.get(i) > listB.get(i);
            }
        }

        return true;
    }

    /**
     * 高精度减法
     * @param listA
     * @param listB
     * @return c = a - b
     */
    private static String subtraction(List<Integer> listA, List<Integer> listB) {
        int t = 0; // 差值

        List<Integer> C = new ArrayList();

        for (int i = 0; i < listA.size(); i ++) {
            t += listA.get(i);

            if (i < listB.size()) {
                t -= listB.get(i);
            }
            C.add((t + 10) % 10); // t >= 0: t; t < 0 : t + 10(借位)

            if (t < 0) {
                t = -1;
            }
            else {
                t = 0;
            }
        }
        while(C.size() > 1 && C.get(C.size() - 1) == 0) {
            C.remove(C.size() - 1); // 删除前导0
        }

        StringBuilder stringBuilder = new StringBuilder();
        C.forEach((item) -> {
            stringBuilder.append(item);
        });
        return stringBuilder.toString();
    }
}
```

### 乘法

```java
import java.util.*;
public class Main{
    static List<Integer> mul(List<Integer> A, int b){
        List<Integer> C = new ArrayList<>();
        int t = 0;
        for(int i = 0; i < A.size() || t != 0; i ++){
            if(i < A.size()){
                t += A.get(i) * b;
            }
            C.add(t % 10);
            t /= 10;
        }
        // 去除前导零
        int j = C.size() - 1;
        while(j > 0 && C.get(j) == 0){
            C.remove(j);
            j --;
        }
        return C;
    }
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String a = sc.next();
        int b = sc.nextInt();
        List<Integer> A = new ArrayList<>();
        for(int i = a.length() - 1; i >= 0; i --){
            A.add(a.charAt(i) - '0');
        }
        List<Integer> C = mul(A, b);
        for(int i = C.size() - 1; i >= 0; i --){
            System.out.print(C.get(i));
        }
    }
}
```

### 除法

```java
import java.util.*;
public class Main{
    static int r = 0; // 余数
    static List<Integer> dev(List<Integer> A, int b){
        List<Integer> C = new ArrayList<>();
        for(int i = 0; i < A.size(); i ++){
            r = A.get(i) + r * 10;
            C.add(r / b);
            r %= b;
        }
        int j = 0;
        while(C.size() > 1 && C.get(j) == 0){
            C.remove(j);
        }
        return C;
    }
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String a = sc.next();
        int b = sc.nextInt();
        List<Integer> A = new ArrayList<>();
        for(int i = 0; i < a.length(); i ++){
            A.add(a.charAt(i) - '0');
        }
        List<Integer> C = dev(A, b);
        for(int i = 0; i < C.size(); i ++){
            System.out.print(C.get(i));
        }
        System.out.println();
        System.out.println(r);
    }
}
```

## 前缀和

### 一维

> Si 表示 数组中 a1 + a2 + …… + ai的数字之和。和差分互为逆运算
>
> 注意问题：
>
> 1. Si = Si-1 + ai
> 2. S0 = 0,方便处理边界
>
> 作用：计算[l~r]的和，for遍历一次是O(n), 前缀和就是Sr-Sl-1,O(1)

```java
import java.util.Scanner;

public class Main {
    
    static final int N = 100010;
    static int n, m;
    static int[] a = new int[N]; // 原数组
    static int[] s = new int[N]; // 前缀和数组 定义为全局变量 数组值全部初始化为0 不需要单独的s[0] = 0
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        
        for (int i = 1; i <= n; i++) {
            a[i] = sc.nextInt();
            s[i] = s[i - 1] + a[i]; // 公式一
        }
        
        while (m-- != 0) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            System.out.println(s[r] - s[l - 1]); // 公式二
        }
    }
}
```

go

```go
package main

import "fmt"

const N = 1e6 + 10

func main() {
    var n, m int
    fmt.Scanf("%d", &n)
    fmt.Scanf("%d", &m)
    
    q := make([]int, N)
    s := make([]int, N)
    
    for i := 1; i <= n; i ++ {
        fmt.Scanf("%d", &q[i])
        // 前缀和初始化
        s[i] = s[i - 1] + q[i]
    }
    
    for {
        
        m --
        if m < 0 {
            break
        }
        
        var l, r int
        fmt.Scanf("%d", &l)
        fmt.Scanf("%d", &r)
        // 前缀和计算输出
        fmt.Printf("%d\n", s[r] - s[l - 1])
    }
    
}
```

### 二维

java

```java
package indi.yuluo.test;


import java.util.Scanner;

/**
 * @Author: yuluo
 * @CreateTime: 2022-12-29  13:57
 * @Description: 二维数组前缀和
 */

public class SumOfPrefixesPlus {


    public static void main(String[] args) {
        // 输入值进行初始化
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int q = in.nextInt();
        // 初始化 arr
        int[][] arr = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                arr[i][j] = in.nextInt();
            }
        }

        // 求解 s[i][j]
        int[][] s = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // 计算, 结合图来理解
                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + arr[i][j];
            }
        }
        // 循环输出
        while ((q--) > 0) {
            // 定位获取区间大小
            int x1 = in.nextInt();
            int y1 = in.nextInt();
            int x2 = in.nextInt();
            int y2 = in.nextInt();

            // 计算, 结合图来理解
            int res = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];
            System.out.println(res);
        }
    }
}
```

go

```go
package main

import (
    "bufio"
    . "fmt"
    "os"
)

var (
    n, m, x1, x2, y1, y2, q, num int
    s = [1010][1010]int{}
)

func main() {
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)
    defer out.Flush()
    _, _ = Scan(&n, &m, &q)
    for i := 1; i <= n; i++ {
        for j := 1; j <= m; j++ {
            _, _ = Fscan(in, &num)
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + num
        }
    }
    for q > 0 {
        _, _ = Fscan(in, &x1, &y1, &x2, &y2)
        _, _ = Fprintln(out, s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1])
        q--
    }
}
```

## 差分

> 有一个数组 a1，a2，a3……ai
>
> 需要构造一个数组使得：ai = b1+b2+b3+……+bi
>
> 一维数组构造：
>
> b1 = a1
>
> b2 = a2 - a1
>
> b3 = a3 - a2
>
> ……
>
> bn = an - an-1
>
> b1+b2相加，尾项会被消除。
>
> 这里：a就是b的前缀和，b就是a的差分。
>
> 差分的作用： 使用O(1)的时间复杂度对数组指定区间中的每一项加上常数C                   

### 一维：

 java



go

```go
package main

import (
    "fmt"
    "os"
    "bufio"
)

const N = 1e6 + 10

var (
    n, m int
    a = make([]int, N)
    b = make([]int, N)
)

func main() {
    
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)
    defer out.Flush()
    
    fmt.Scan(&n, &m)
    
    for i := 1; i <= n; i ++ {
        fmt.Fscan(in, &a[i])
    }
    for i := 1; i <= n; i++ {
        Insert(i, i, a[i])
    }
    
    for m > 0 {
        var l, r, c int
        fmt.Fscan(in, &l, &r, &c)
        Insert(l, r, c)
        m --
    }
    
    for i := 1; i <= n; i ++ {
        b[i] += b[i - 1]
    }
    
    for i := 1; i <= n; i ++ {
        fmt.Fprint(out, b[i], " ")
    }
}

func Insert(l, r, c int) {
    b[l] += c
    b[r + 1] -= c
}
```

### 二维

go

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)

var scanner *bufio.Scanner
var b [][]int

func readline() []int{
    scanner.Scan()
    l := strings.Split(scanner.Text(), " ")

    res := make([]int, len(l))
    for i, s := range l {
        x, _ := strconv.Atoi(s)
        res[i] = x
    }
    return res
}

func mody(x1, y1, x2, y2, c int){
    b[x1][y1] += c
    b[x2+1][y1] -= c
    b[x1][y2+1] -= c
    b[x2+1][y2+1] += c
}

func main(){
    scanner = bufio.NewScanner(os.Stdin)
    bs := make([]byte, 20000*1024)
    scanner.Buffer(bs, len(bs))
    var n, m, q int
    _, _ = fmt.Scanf("%d%d%d", &n, &m, &q)
    b = make([][]int, n+2)
    for i:=0; i<n+2; i++{
        b[i] = make([]int, m+2)
    }
    for i:=1; i<=n; i++{
        p := readline()
        for j:=0; j<m; j++{
            mody(i, j+1, i, j+1, p[j])
        }
    }
    for i:=0; i<q; i++{
        x := readline()
        mody(x[0], x[1], x[2], x[3], x[4])
    }
    for i:=1; i<=n; i++{
        y := make([]string, m)
        for j:=1; j<=m; j++{
            b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]
            y[j-1] = strconv.Itoa(b[i][j])
        }
        fmt.Println(strings.Join(y, " "))
    }
}
```

## 双指针算法

```java
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

上面这种都可以称为双指针算法。

> 1. 先暴力写出步骤，看i和j之间有没有什么单调关系
> 2. 如果有，就可以使用双指针算法解决

### Acwing 801 最长连续不重复子序列

java:

```java
import java.util.Scanner;

public class Main{
    
    static int N = (int) 1e6 + 10;
    static int n;
    static int[] a = new int[N];
    static int[] s = new int[N];
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        
        for (int i = 0; i < n; i ++) {
            a[i] = sc.nextInt();
        }
        
        int res = 0;
        for (int i = 0, j = 0; i < n; i ++) {
            s[a[i]] ++;
            while (s[a[i]] > 1) {
                s[a[j]] --;
                j ++;
            } 
            res = Math.max(res, i - j + 1);
        }
        System.out.println(res);
    }
}
```

go:

```go
package main

import (
    "fmt"
    "math"
)

const N = 1e6 + 10

func main() {
    var n int
    fmt.Scanf("%d", &n)
    
    a := make([]int, N)
    s := make([]int, N)
    
    for i := 0; i < n; i ++ {
        fmt.Scanf("%d", &a[i])
    }
    var res int
    for i, j := 0, 0; i < n; i ++ {
        s[a[i]] ++;
        for s[a[i]] > 1 {
            s[a[j]] --
            j ++
        }
        
        res = int(math.Max(float64(res), float64(i - j + 1)))
    }
    
    fmt.Printf("%d", res)
}
```

### Acwing 2816 判断子序列

go

```go
package main

import (
    "fmt"
    "os"
    "bufio"
)

var n, m int
const N = 1e5 + 10


func main() {
    
    // 使用scanf会TLE
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)
    defer out.Flush()
    
    fmt.Fscan(in, &n, &m)
    
    a := make([]int, N)
    b := make([]int, N)
    
    for i := 0; i < n; i ++ {
        fmt.Fscan(in, &a[i])
    }
    
    for i := 0; i < m; i ++ {
        fmt.Fscan(in, &b[i])
    }
    // i和j两个指针，先判断a[i]和b[j]的位置是否相等，
    // 如果相等，i和j都移动一位。
    // 如果不相等，只移动j指针，循环直到j走完b数组
    i, j := 0, 0
    for j < m && i < n {
        if a[i] == b[j] {
            i ++
            j ++
        } else {
            j ++
        }
    }
    // 最后判断i是否走完a数组，走完则证明可以通过b得到a序列
    if i == n {
        fmt.Println("Yes")
    } else {
        fmt.Println("No")
    }
    
}
```

### Acwing 800 数组元素的目标和

```go
package main

import (
    "fmt"
    "os"
    "bufio"
)

const N = 1e5 + 10
var n, m, x int

func main() {
    
    in := bufio.NewReader(os.Stdin)

    a := make([]int, N)
    b := make([]int, N)
    
    fmt.Fscan(in, &n, &m, &x)
    
    for i := 0; i < n; i ++ {
        fmt.Fscan(in, &a[i])
    }

    for i := 0; i < m; i ++ {
        fmt.Fscan(in, &b[i])
    }

    for i, j := 0, m - 1; i < n; i ++ {
        for j >= 0 && a[i] + b[j] > x {
            j --
        }
        if j >= 0 && a[i] + b[j] == x {
            fmt.Printf("%d %d\n", i, j)
        }
    }
}
```

## 位运算常用操作

```go
package main

import "fmt"

func main(){
    var n,x int
    fmt.Scan(&n)
    for i:=0;i<n;i++{
        // 读取
        fmt.Scan(&x)
        // 输出
        fmt.Print(get(x)," ")
    }
}

func get(n int) (res int){
    // 右移 统计1的个数
    for n != 0{
        if (n & 1) == 1{
            res ++
        }
        n >>= 1
    }
    return
}
```

## 离散化

特指整数的离散化：**将值映射到下标**

> 1. 离散化，把无限空间中有限的个体`映射`到有限的空间中去，以此提高算法的时空效率。
>    通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。
>    `离散化本质上可以看成是一种哈希`
> 2. a数组中可能有重复元素   去重
> 3. 如何算出a[i]离散化后的值
>
> 做题步骤：
>
> - 排序
> - 去重
> - 二分求离散化的值

java awing 802 区间和

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();//n次操作
        int m = scan.nextInt();//m次询问
        int N = 300010;//表示需要用到的下标数量，因为一开始可能重复，所以按照最大可能开最大的数组；
        int[] a =  new int[N]; //用来存值,从一开始的值，因为要用到前缀和，所以0不操作；
        int[] s = new int[N];//用来存前缀和，从一开始进行记录a数组；
        List<Integer> alls = new ArrayList<>();//用来存所有的下标，x,l,r;
        //因为可能会重复乱序，所以需要进行去重，排序；
        List<Pair> add = new ArrayList<>();//用来存n次操作
        List<Pair> query = new ArrayList<>();//用来存m次询问
        //输入n次操作，每次操作存入add集合中，然后将下标x存入alls集合中
        for(int i = 0 ; i < n ; i ++ ){
            int x = scan.nextInt();
            int c = scan.nextInt();
            add.add(new Pair(x,c));
            alls.add(x);
        }
        //输入m次询问，每次询问存入query集合中，因为l,r是求和的下标区间和，所以l,r都存入alls集合中。
        for(int i = 0 ; i < m ; i ++ ){
            int l = scan.nextInt();
            int r = scan.nextInt();
            query.add(new Pair(l,r));
            alls.add(l);
            alls.add(r);
        }

        Collections.sort(alls);   //排序，现在alls集合中存的是x，l，r所有值
        int unique = unique(alls);  //这一步是去重，因为l，x，r中可能有重复的数；
        alls = alls.subList(0,unique);  //将去重之后的alls的长度范围中的值重新赋值给alls集合中。

        //增强for循环 for(元素类型 变量名 ： 数组或者集合) 缺点：无下标，简单。
        for(Pair item : add){
            int index = find(item.first,alls);//
            a[index] += item.second;//
        }

        for(int i = 1 ; i <= alls.size() ; i ++ ) s[i] = s[i-1] + a[i]; //这是前缀和公式代码

        for(Pair item : query){
            int l = find(item.first,alls); // 
            int r = find(item.second,alls); // 
            System.out.println(s[r] - s[l-1]); // 
        }

    }
    //去重（只要符合是第一个数或者后面一个数不等于前面一个数就是不重复的数）
    public static int unique(List<Integer> list){
        int j = 0;
        for(int i = 0 ; i <= list.size() - 1; i ++ ){
            if(i == 0 || list.get(i) != list.get(i-1)){
                list.set(j,list.get(i)); //将不重复之后的数一个一个重新存入list中。
                j ++ ;
            }
        }
        return j;
    }
 //二分查找（在集合中查找你现在的下标是在什么位置，因为需要符合我们要用的前缀和公式，要让下标不是从0输出，最低的下标是1，符合前缀和的从1开始，所以输出的值加1）
    public static int find(int x ,List<Integer> list){
        int l  = 0;
        int r = list.size() - 1;
        while(l < r){
            int mid = ( l + r )/ 2;
            if(list.get(mid) >= x) r = mid;
            else l = mid + 1;
        }
        return l + 1;
    }
}   
//这是一个Pair类，用来存操作的类
   class Pair{
        int first;
        int second;
        public Pair(int x,int c){
            this.first = x;
            this.second = c;
        }
    }
```

## 区间合并

将两个有交集的区间，快速合并成为一个区间，**贪心**

> 1. 按区间左端点排序
> 2. 扫描整个区间，过程中，将所有可能的区间合并

go acwing803 区间合并

```go
package main

import (
    "fmt"
    "bufio"
    "math"
    "os"
    "sort"
    "strconv"
    "strings"
)

// 模拟pair，存储区间左右端点
type pair struct {
    first  int
    second int
}

var scanner *bufio.Scanner

func main() {
    // 使用scanner读取输入
    scanner = bufio.NewScanner(os.Stdin)
    bs := make([]byte, 20000 * 1024)
    scanner.Buffer(bs, len(bs))

    var n = readLine()[0]
    segs := make([]pair, 0)

    for i:= 0; i < n; i ++ {
        x := readLine()
        // 读入每个区间的左右节点
        segs = append(segs, pair{x[0], x[1]})
    }

    // 调用区间合并模板
    res := merge(segs)

    fmt.Println(len(res))
}

// 归并
func merge(segs []pair) []pair {
    // 定义区间合并后的结果
    var res []pair

    // 排序
    sort.Slice(segs, func(i, j int) bool {
        // 如果左端点相同 再以右端点排序
        if segs[i].first == segs[j].first {
            return segs[i].second < segs[j].second
        }
        //优先以左端点大小排序
        return segs[i].first < segs[j].first
    })

    // 从左往右扫描，维护当前区间
    // 设置边界大小为正无穷到负无穷
    start, end := math.MinInt32, math.MinInt32
    // 遍历pair类型的数组中存储的所有区间
    for _, seg := range segs {
        // 没有交集的情况
        if end < seg.first {
            if start != math.MinInt32 {
                // 没有交集，就结果+1，将当前区间加入到结果res中去
                res = append(res, pair{start, end})
            }
            // 更新处理下一个区间
            start, end = seg.first, seg.second
        } else {
            // 有交集
            if seg.second > end {
                // 扩展合并区间
                end = seg.second
            }
        }
    }

    // 避免seg为空的情况发生
    if start != math.MinInt32 {
        res = append(res, pair{start, end})
    }

    // 更新当前维护的区间
    return res
}

// 按行读入 处理输入返回一个int数组，包含区间起点和终点
func readLine() []int {
    scanner.Scan()
    l := strings.Split(scanner.Text(), " ")

    res := make([]int, len(l))
    for i, s := range l {
        x, _ := strconv.Atoi(s)
        res[i] = x
    }
    return res
}
```

## 问题

> 第一讲中还需要看的问题
>
> 1. Acwing 800 数组元素的目标和 （双指针算法）
> 2. 离散化区间和
> 3. 二分模板
> 4. 前缀和和差分模板

## 第二讲

### 链表与邻节表

#### 数组模拟单（静态）链表（优点：快）

邻接表的作用：1，存储图和树

```go
package main

import "fmt"

const N int = 1e6 + 10

// head表示头结点的下标
// e[i] 表示节点 i 的值
// ne[i] 表示节点i的next指针是多少
// idx 存储当前已经用到的那个点
var (
    head, idx int
    e = make([]int, N)    
    ne = make([]int, N)
)

// init 初始化链表
func new() {
    head = -1
    idx = 0
}

// 将x插入到头结点 两步：1.将x的next指针指向head指向的位置 2. head的next指针指向x的下标
func addToHead(x int) {
    e[idx] = x
    ne[idx] = head;
    head = idx
    // idx 后移一位
    idx ++
}

// add 将x插入到链表指针k的后面
func add(k, x int) {
    e[idx] = x
    ne[idx] = ne[k]
    ne[k] = idx
    idx ++
}

// 删除下标是k的点后面的元素  直接让k位置的next指针指向k的下一个的下一个next指针
func remove(k int) {
    ne[k] = ne[ne[k]]
}

// 遍历链表
func traverse(head int) []int {
    res := []int{}
    for i := head; i != -1; i = ne[i] {
        // fmt.Printf("%d\t", e[i])
        res = append(res, e[i])
    }
    return res
}


func main() {
    
    new()
    
    var m int
    fmt.Scanf("%d", &m)
    
    for ; m > 0; m -- {
        // go 没有char类型
        var op string
        fmt.Scanf("%s", &op)
        
        switch op {
        case "H":
            var x int
            fmt.Scanf("%d", &x)
            addToHead(x)
        case "I":
            var k, x int
            fmt.Scanf("%d%d",&k,&x)
            // 因为 idx 是从0开始的，这里的下标值要-1
            add(k - 1, x)
        case "D":
            var k int
            fmt.Scanf("%d", &k)
            if k == 0 {
                head = ne[head]
            } else {
                // fmt.Printf("%d", k)
                remove(k - 1)
            }
        }
    }
    
    res := traverse(head)
    for i := range res {
        fmt.Printf("%d ", res[i])
    }
}
```

#### 数组模拟双链表

> 有两个指针，一个指向前，一个指向后

优化某些问题

go

```go
package main

import "fmt"

const N int = 1e6 + 10

var (
	m, idx int
    e = make([]int, N)
    l = make([]int, N)
    r = make([]int, N)
)

// 双链表初始化
func new() {
    // 0 表示 左端点，1 表示右端点
    r[0], l[1] = 1, 0
    // 0和1 都被用了，所以从2开始
    idx = 2
}

// 插入 数
func add(k, x int) {
    e[idx] = x
    r[idx] = r[k]
    l[idx] = k
    l[r[idx]] = idx
    r[k] = idx
    idx ++
}

// 删除数
func remove(k int) {
    r[l[k]] = r[k]
    l[r[k]] = l[k]
}

func main() {
    
    new()

    fmt.Scanf("%d", &m)
    
  for ; m > 0; m-- { // 接下来M行，每行包含一个操作命令
        var op string
        fmt.Scanf("%s", &op)
        switch op {
        case "L":
            var x int
            fmt.Scanf("%d", &x)
            add(0, x)
        case "R":
            var x int
            fmt.Scanf("%d", &x)
            add(l[1], x)
        case "D":
            var k int
            fmt.Scanf("%d", &k)
            remove(k + 1)
        case "IL":
            var k, x int
            fmt.Scanf("%d%d", &k, &x)
            add(l[k+1], x)
        case "IR":
            var k, x int
            fmt.Scanf("%d%d", &k, &x)
            add(k+1, x)
        }

    }
    
    // fmt.Printf("%v\n", e[r[1]])
    
    for i := r[0]; i != 1; i = r[i] {
        fmt.Printf("%d ", e[i])
    }
    
}
```

#### 邻接表

在图论中讲

### 栈和队列

#### 栈

> 先进后出

acwing 828 模拟栈

```go
package main

import "fmt"

const N int = 1e6 + 10

var (
    // 栈指针
	tt int
    // 模拟栈的数组
    stk = make([]int, N)
)

// push x 向栈顶插入数 x
func push(x int) {
    tt = tt + 1
    stk[tt] = x
}

// pup 从栈顶弹出一个数
func pop() (num int) {
    num = stk[tt]
    tt --
    return
}

// 判断栈是否为空
func empty() {
    if tt > 0 {
        fmt.Println("NO")
    } else {
        fmt.Println("YES")
    }
}

// 查询栈顶元素
func query() (num int) {
    num = stk[tt]
    return 
}

func main() {
    var m int
    fmt.Scanf("%d", &m)
    
    for ; m > 0; m -- {
        var op string
        fmt.Scanf("%s", &op)
        switch op {
        case "push":
            var x int
            fmt.Scanf("%d", &x)
            push(x)
        case "query":
            fmt.Printf("%d\n", query())
        case "pop":
            pop()
        case "empty":
            empty()
        }
    }
}
```

acwing 表达式求值

```go
package main

import (
    "bufio"
    "fmt"
    "math"
    "os"
    "strconv"
)

var sc = bufio.NewScanner(os.Stdin)
var wr = bufio.NewWriter(os.Stdout)

func out(x ...interface{}) {
    fmt.Fprintln(wr, x)
}

func getI() int {
    sc.Scan()
    i, e := strconv.Atoi(sc.Text())
    if e != nil {
        panic(e)
    }
    return i
}

func getIns(N int) []int {
    ret := make([]int, 0)
    for i := 0; i < N; i++ {
        ret = append(ret, getI())
    }
    return ret
}

func getS() string {
    sc.Scan()
    return sc.Text()
}

type Stack struct {
    sk []interface{}
    tt int
}

func NewStack(N int) *Stack {
    return &Stack{
        sk: make([]interface{}, N),
        tt: 0,
    }
}

func (stack *Stack) push(x interface{}) {
    stack.sk[stack.tt] = x
    stack.tt += 1
}

func (stack *Stack) pop() interface{} {
    ret := stack.sk[stack.tt-1]
    stack.tt -= 1
    return ret
}

func (stack *Stack) peek() interface{} {
    return stack.sk[stack.tt-1]
}

func (stack *Stack) empty() bool {
    return stack.tt <= 0
}

var (
    N        = 100010
    sk1      = NewStack(N)
    sk2      = NewStack(N)
    priority = map[rune]int{
        '+': 1,
        '-': 1,
        '*': 2,
        '/': 2,
    }
)

func IsNum(x rune) bool {
    return x >= '0' && x <= '9'
}

func Calculate() {
    b := sk2.pop().(int)
    a := sk2.pop().(int)
    c := sk1.pop().(rune)
    switch c {
    case '+':
        sk2.push(a + b)
    case '-':
        sk2.push(a - b)
    case '*':
        sk2.push(a * b)
    case '/':
        sk2.push(a / b)
    }
}
func main() {
    defer wr.Flush()
    sc.Split(bufio.ScanWords)
    sc.Buffer([]byte{}, math.MaxInt32)

    arr := []rune(getS())
    for i := 0; i < len(arr); i++ {
        cx := arr[i]
        if IsNum(cx) {
            k, x := i, 0
            for k < len(arr) && IsNum(arr[k]) {
                x = x*10 + int(arr[k]-'0')
                k += 1
            }
            sk2.push(x)
            i = k - 1
        } else if cx == ')' {
            for !sk1.empty() && sk1.peek() != '(' {
                Calculate()
            }
            sk1.pop()
        } else {
            for cx != '(' && !sk1.empty() && sk1.peek() != '(' && priority[sk1.peek().(rune)] >= priority[cx] {
                Calculate()
            }
            sk1.push(cx)
        }
    }
    for !sk1.empty() {
        Calculate()
    }
    fmt.Println(sk2.pop())
}
```

#### 队列

> 先进先出

```go
package main

import "fmt"

const N int = 1e6 + 10
var (
    // 队头和队尾
	hh, tt int
    // 队列
    q = make([]int, N)
)

// 初始化
func new() {
    // 初始化从 -1 开始
    hh, tt = 0, -1
}

// push 插入 x
func push(x int) {
    tt = tt + 1
    q[tt] = x
    // fmt.Printf("%v", q)
}

// pop 弹出元素
func pop() {
    hh ++
}

// 判断是否为空
func empty() {
    if hh <= tt {
        fmt.Println("NO")
    } else {
        fmt.Println("YES")
    }
}

// 取出队头元素
func getQueueHead() (num int) {
    return q[hh]
}

// 取出队尾元素
func getQueueTail() (num int) {
    return q[tt]
}

func main() {
    
    new()
    
    var x int
    fmt.Scanf("%d", &x)
    for ; x > 0; x -- {
        var op string
        fmt.Scanf("%s", &op)
        switch op {
        case "push":
            var num int
            fmt.Scanf("%d", &num)
            push(num)
        case "empty":
            empty()
        case "query":
            fmt.Println(getQueueHead())
        case "pop":
            pop()
        }
    }
}
```

#### 单调栈

给定一个数，要求出这个数左（右）边的离他最近的数且比他小的数在什么地方？

> 例如：如果在左边且比它小的数，返回这个数，没有返回-1
>
> 3  4  2  7  5
>
> -1 3 -1  2  2
>
> 暴力做法：
>
> 暴力做法存在的性质：可以使用栈来模拟
>
> ```go
> for i := 0; i < n; i ++ {
> ​	for j := i - 1; j >= 0; j -- {
> ​		if a[i] > a[j] {
> ​			fmt.Printf("%d", a[j])
> ​		}
> ​	}
> }
> ```

acwing 830 单调栈

出栈一次，进栈一次 O(2n) -> O(n)

```go
package main

import "fmt"

const N int = 1e6 + 10

var (
	n, tt int
    stk = make([]int, N)
)

func main() {
    fmt.Scanf("%d", &n)
    for i := 0; i< n; i ++ {
        var x int
        fmt.Scanf("%d", &x)
        for tt > 0 && stk[tt] >= x {
            tt --
        }
        if tt > 0 {
            fmt.Printf("%d ", stk[tt])
        } else {
            fmt.Printf("-1 ")
        }
        tt = tt + 1 
        stk[tt] = x
    }
}
```

> leetcode 接雨水问题

#### 单调队列

acwing 154 滑动窗口

```go
package main

import "fmt"

const N int = 1e6 + 10

var (
	n, k int
    a = make([]int, N)
    q = make([]int, N)
)

func main() {
    fmt.Scanf("%d%d", &n, &k)
    
    for i := 0; i < n; i ++ {
        fmt.Scanf("%d", &a[i])
    }
    
    // 最小值
    hh, tt := 0, -1
    for i := 0; i < n; i ++ {
        // 判断队头是否已经滑出窗口
        if hh <= tt && i - k + 1 > q[hh] {
            hh ++
        }
        for hh <= tt && a[q[tt]] >= a[i] {
            tt --
        }
        tt = tt + 1
        q[tt] = i
        if i >= k - 1 {
            fmt.Printf("%d ", a[q[hh]])
        }
    }
    
    fmt.Println()
 
    // 最大值
    hh, tt = 0, -1
    for i := 0; i < n; i ++ {
        // 判断队头是否已经滑出窗口
        if hh <= tt && i - k + 1 > q[hh] {
            hh ++
        }
        for hh <= tt && a[q[tt]] <= a[i] {
            tt --
        }
        tt = tt + 1
        q[tt] = i
        if i >= k - 1 {
            fmt.Printf("%d ", a[q[hh]])
        }
    }
}
```

这里使用`fmt.Scanf()` 会超时，要使用 `in := bufio.NewReader(os.Stdin)`

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)

// 哈希取模的数一般为质数，并且并可能离2的整数次幂远
const N = 100003

var (
    h [N]int    
    e [N]int
    ne [N]int
    idx int
    s = make([]string, 4)
)

func main() {
    
    // 初始化h数组
    for k, _ := range h {
        h[k] = -1
    }
    
    var m int
    fmt.Scanf("%d", &m)
    input := bufio.NewReader(os.Stdin)
    
    for ; m > 0; m -- {
        readLine(s, input)
        x, _ := strconv.Atoi(s[1])
        
        if s[0] == "I" {
            insert(x)
        }  else {
            if find(x) {
                fmt.Println("Yes")
            } else {
                fmt.Println("No")
            }
        }
    }
}

func insert(x int) {
    // 哈希函数
    k := (x % N + N) % N
    e[idx] = x
    ne[idx] = h[k]
    h[k] = idx
    
    idx ++
}

func find(x int) bool {
    k := (x % N + N) % N
    
    // 遍历数组值下面的链表，找到数
    for i := h[k]; i != -1; i = ne[i] {
        if e[i] == x {
            return true
        }
    }
    
    return false
}

func readLine(s []string, input *bufio.Reader) {
    str, _ := input.ReadString('\n')
    strslice := strings.Fields(str)
    for k, v := range strslice {
        s[k] = v
    }
}
```

### Trie树

> 用来快速**查找和存储**字符串集合的数据结构

<img src="D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230202154646022.png" alt="image-20230202154646022" style="zoom:50%;" />

```go
package main

import (
    "fmt"
    "os"
    "bufio"
)

const N = 1e5 + 10

var (
    idx int // 下标 注意：下标是0的点，既是根节点又是空节点   
    son [][]int
    cnt = make([]int , N)
)

// 插入操作
func insert(str string) {
    p := 0
    for i := 0; i < len(str); i ++ {
        u := str[i] - 'a'  // 这样做是为了将字符串映射到0-25的位置上。ACSII码值-a
        if son[p][u] == 0 {
            idx ++
            son[p][u] = idx
        }
        p = son[p][u]
    }
    
    cnt[p] ++ // 表示以p结尾的字母有一个单词
}

func query(str string) {
    p := 0
    for i := 0; i < len(str); i ++ {
        u := str[i] - 'a'
        if son[p][u] == 0 {
            fmt.Println(0)
            // 这里的return是必需的，确保有一个单词时就返回结果，而不继续向下查找
            return
        }
        p = son[p][u]
    }
    
    fmt.Println(cnt[p])
}

func main() {
    
    // 初始化节点数组
    for i := 0; i < N; i ++ {
        tmp := make([]int, 26)
        son = append(son, tmp)
    }
    
    in := bufio.NewReader(os.Stdin)
    
    var n int
    fmt.Fscan(in, &n)
    
    for ; n > 0; n -- {
        var op, str string
        fmt.Fscan(in, &op, &str)
        if op == "I" {
            insert(str)
        } else {
            query(str)
        }
    }
    
}
```

### 并查集

> - 将两个集合合并
> - 询问两个元素是否在一个集合当中
>
> 基本原理：每个集合用一颗树表示，树根的编号就是整个集合的编号，每个节点存储他的父节点，p[x] 表示 x的父节点
>
> 1. 如何判断树根： if (p[x] == x)
> 2. 如何求x的集合编号：while(p[x] != x) x = p[x];  **优化：路径压缩**
> 3. 如何合并两个集合：px是x的集合编号，py是y的集合编号，p[x] = y; (链接树)

```go
package main

import "fmt"

const N = 1e5 + 10

var (
    n, m int
    p = make([]int, N)
)

// 返回x的祖宗节点 + 路径压缩
func find(x int) int {
    if p[x] != x {
        p[x] = find(p[x])
    }
    
    return p[x]
}

func main() {
    
    fmt.Scanf("%d%d", &n, &m)
    for i := 1; i <= n; i ++ {
        p[i] = i
    }
    
    for ;m > 0; m -- {
        var op string
        var a, b int
        fmt.Scanf("%s%d%d", &op, &a, &b);
        
        if op == "M" {
            p[find(a)] = find(b)
        } else {
            if find(a) == find(b) {
                fmt.Println("Yes")
            } else {
                fmt.Println("No")
            }
        }
    
    }
    
}
```

### 堆

> 1. 插入数			  `heap[ ++ size] = x, up(size)`
> 2. 求集合中的最小值      `heap[1]`
> 3. 删除最小值           `heap[1] = heap[size]; size --; down(1)`
> 4. 删除任意一个元素      `heap[k] = heap[size], size --; down(k), up(k) 变大down，变小up，都执行一遍，不用判断 `
> 5. 修改任意一个元素      `heap[k] = x; down(k); up(k)`
>
> **完全二叉树：最后一层上面的所有节点都是满的，最后一层节点是从左向右依次排布的**
>
> 小根堆：每一个点都是小于等于左右儿子的，所以根节点是此数据结构的最小值
>
> 堆存储：一维数组，x是根节点，x的左儿子是2x，右儿子是2x + 1
>
> 操作：down(x) up(x) down是下移节点，up上移节点
>
> 使用
>
> <img src="D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230204121238161.png" alt="image-20230204121238161" style="zoom:50%;" />
>
> ```go
>     // O(n)的时间复杂度建堆 down操作
>     for i := n / 2; i; i -- {
>         down(h[i])
>     }
> ```

Acwing 堆排序：

```go
package main

import (
    "fmt"
    "bufio"
    "os"
)

// 并查集
const N = 1e5 + 10

// 保存元素父节点
var (
    n, m int
    p =make([]int, N)
    size = make([]int, N)
)

// 返回x的祖宗节点 + 路径压缩优化
func find(x int) int {
    
    if p[x] != x {
        p[x] = find(p[x])
    }
    return p[x]
}

func merge(x, y int) {
    a := find(x)
    b := find(y)
    
    if a != b {
        p[b] = a
        size[a] += size[b]
    }
}

func query(x, y int) {
    // return find[x] = find[y]
    if find(x) == find(y) {
        fmt.Println("Yes")
    } else {
        fmt.Println("No")
    }
}

func main() {
    in := bufio.NewReader(os.Stdin)
    fmt.Fscan(in, &n, &m)
    // 初始化所有集合
    for i := 1; i <= n; i ++ {
        p[i] = i
        size[i] = 1
    }
    
    for ; m != 0; m -- {
        var op string
        var a, b int
        
        fmt.Fscan(in, &op, &a, &b)
        if op == "C" {
            merge(a, b)
        } else if op == "Q1" {
            query(a, b)
        } else if op == "Q2" {
            fmt.Println(size[find(a)])
        }
    }
}
```

### kmp

> 著名的字符串匹配算法

暴力算法解释：

```go
s := make([]int, N)
p := make([]int, M)

for i := 1; i <= n; i ++ {
    var flag bool
    for j := 1; j <= m; j ++ {
        if s[i] != p[j] {
            flag = false
            break
        }
    }
}
```

### 哈希表

#### 存储结构

处理哈希冲突的两种方式

1. 开放寻址法：如果当前位置有数，往后一位去看，没有数放进去

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)

// 因为开放寻址法的原因，多开一倍数组空间
const N = 200003

var (
    h [N]int    
    s = make([]string, 4)
)

func main() {
    
    // 初始化h数组 初始化成题目给定的数范围之外的数
    for k, _ := range h {
        h[k] = 2E10
    }
    
    var m int
    fmt.Scanf("%d", &m)
    input := bufio.NewReader(os.Stdin)
    
    for ;m>0;m--{
        readLine(s,input)
        x,_:=strconv.Atoi(s[1])
        k:=find(x)
        if s[0]=="I"{
            h[k]=x
        }else {
            if h[k]!=2E10{
                fmt.Println("Yes")
            }else {
                fmt.Println("No")
            }
        }
    }
}

func find(x int) int {
    // 哈希函数
    k:=(x%N+N)%N
    for h[k]!=2E10 && h[k]!=x {
        k++
        if k == N {
            k=0
        }
    }
    return k
}

func readLine(s []string, input *bufio.Reader) {
    str, _ := input.ReadString('\n')
    strslice := strings.Fields(str)
    for k, v := range strslice {
        s[k] = v
    }
}
```

1. 拉链法

Acwing 840 模拟散列表

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)

// 哈希取模的数一般为质数，并且并可能离2的整数次幂远
const N = 100003
var h [N]int
var e [N]int
var ne [N]int
var idx int

var s = make([]string, 4)

func main() {
    
    // 初始化h数组
    for k, _ := range h {
        h[k] = -1
    }
    
    var m int
    fmt.Scanf("%d", &m)
    input := bufio.NewReader(os.Stdin)
    
    for ; m > 0; m -- {
        readLine(s, input)
        x, _ := strconv.Atoi(s[1])
        
        if s[0] == "I" {
            insert(x)
        }  else {
            if find(x) {
                fmt.Println("Yes")
            } else {
                fmt.Println("No")
            }
        }
    }
}

func insert(x int) {
    // 哈希函数
    k := (x % N + N) % N
    e[idx] = x
    ne[idx] = h[k]
    h[k] = idx
    
    idx ++
}

func find(x int) bool {
    k := (x % N + N) % N
    
    // 遍历数组值下面的链表，找到数
    for i := h[k]; i != -1; i = ne[i] {
        if e[i] == x {
            return true
        }
    }
    
    return false
}

func readLine(s []string, input *bufio.Reader) {
    str, _ := input.ReadString('\n')
    strslice := strings.Fields(str)
    for k, v := range strslice {
        s[k] = v
    }
}
```

#### 字符串哈希方式

> 字符串前缀哈希法：先求出每个字符串前缀的hash
>
> ABCDEFGHTYJD
>
> ```java
> h[1] = "A"
> h[2] = "AB"
> h[3] = "ABC"
> ……
> ```
>
> 1. 将字符串看成一个P进制的数
>
> <img src="D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230201150418842.png" alt="image-20230201150418842" style="zoom:50%;" />
>
> 1. 将P进制的数转换成十进制
> 2. 模Q，将字符串映射到0~Q-1的范围内
>
> 注意点：
>
> - 字符不能映射成0
> - Rp（人品）足够好，不存在冲突
> - 经验值：p = 131 或者 p = 13331时 Q = 2^64 这种情况下，99.99%的情况下不会发生哈希冲突
>
> **这样处理的好处是：可以使用字符串算出任意字符串的hash值**
>
> <img src="D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230201151350395.png" alt="image-20230201151350395" style="zoom:50%;" />
>
> 任意字符串哈希值为：`h[R] - h[L] * p^(R -L + 1)`

## 第三讲

### DFS（暴搜，深度优先搜索）

> 尽量往深了搜索，到最后一个叶子节点之后才返回。
>
> 回溯：回退到上一步，恢复现场，去和回的时候状态一致。
>
> 剪枝：提前判断此路径不通，不去此路径。

Acwing 全排列问题 842

<img src="D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230204155347248.png" alt="image-20230204155347248" style="zoom:50%;" />

```golang
package main

import "fmt"

// 留出额外空间
const N int = 7 + 3

var (
	n int
    // 用于恢复现场
    path = make([]int, N)
    // 布尔数组用来记录那些数已经使用过了
    status = make([]bool, N)
)

func dfs(u int) {
    // 当u等于n的时候 就是最后一个叶子节点
    if u == n {
        for i := 0; i < n; i ++ {
            fmt.Printf("%d ", path[i])
        }
        // 输出空行
        fmt.Println()
    }
    
    // 找到一个没有使用的点
    for i := 1; i <= n; i ++ {
        if status[i] != true {
            path[u] = i
            status[i] = true
            // 递归下一层
            dfs(u + 1)
            // 回复现场
            status[i] = false;
        }
    }
}

func main() {
    
    fmt.Scanf("%d", &n)
    
    dfs(0);
}
```

Acwing 843 n-皇后问题

```go
package main

import "fmt"

// 留出额外空间
const N int = 9 + 9

var (
	n int
    // 方案
    g [][]string
    // 布尔数组用来记录那些数已经使用过了
    status = make([]bool, N)
    // dg表示对角线，udg表示反对角线
    col, dg, udg = make([]bool, N), make([]bool, N), make([]bool, N)
)

func dfs(u int) {
    // 当u等于n的时候 就是最后一个叶子节点
    if u == n {
        for i := 0; i < n; i ++ {
            for j := 0; j < n; j++ {
                fmt.Print(g[i][j])
            }
            fmt.Println()
        }
        // 输出空行
        fmt.Println()
    }
    
    // 找到一个没有使用的点
    for i := 0; i < n; i ++ {
        // 这一列之前没有放过 && 对角线上没有放过 && 反对角线也没有放过
        if !col[i] && !dg[u+i] && !udg[n-u+i] {
            g[u][i] = "Q"
            // 这一行这一条对角线和反对角线都不能有皇后
            col[i], dg[i + u], udg[n - u + i] = true, true, true
            // 递归下一层
            dfs(u + 1)
            // 恢复现场
            col[i], dg[u + i], udg[n - u + i]  = false, false, false
            g[u][i] = "."
        }
    }
}

func main() {
    
    fmt.Scanf("%d", &n)
    
    g = make([][]string, N)
    for i := 0; i < len(g); i++ {
        g[i] = make([]string, N)
    }
    
    // 初始化方案二维数组
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            g[i][j] = "." // 初始化
        }
    }
    
    dfs(0)
}
```

### BFS（宽度优先搜索）

> 一层一层搜索，每一层的所有节点全部搜完之后进行下一层。

acwing 844 走迷宫

```go
package main

import "fmt"

const N  = 110

// 定义 pair
type pair struct {
    first, second int
}

var (
    g [][]int
    d [][]int
    n, m int
)

func bfs() int {
    q := make([]pair, 0)
    q = append(q, pair{0, 0})
    // 向量表示向上或者向下
    dx := []int{-1, 0, 1, 0}
    // 表示向左或者向右
    dy := []int{0, 1, 0, -1}
    
    for len(q) > 0 {
        // 取出队头元素
        t := q[0]
        q = q[1:]
        a, b := t.first, t.second
        
        // 发别枚举四个方向值
        for i := 0; i < 4; i ++ {
            // 表示沿着此方向走
            lx := a + dx[i]
            // 可以走到那个点
            ly := b + dy[i]
            // 没有走出边界，并且是没有走过
            if lx >= 0 && lx < n && ly >= 0 && ly < m && g[lx][ly] == 0 && d[lx][ly] == -1 {
                // 记录到此点的距离
                d[lx][ly] = d[a][b] + 1
                // 记录进入队列
                q = append(q, pair{lx, ly})
            }
        }
    }
    
    // 输出右下角点的距离
    return d[n - 1][m - 1]
}

func main() {
    fmt.Scanf("%d%d", &n, &m)
    g = make([][]int, N)
    d = make([][]int, N)
    
    for i := 0; i < n; i ++ {
        g[i] = make([]int, m)
        d[i] = make([]int, m)
        for j := 0; j < m; j ++ {
            // 读入地图数据，
            fmt.Scanf("%d", &g[i][j])
            // 初始化为1时，表示地图没有走过
            d[i][j] = -1
        }
    }
    
    // 表示位置已经走过了
    d[0][0] = 0
    
    fmt.Printf("%d", bfs())
    
}
```



#### DFS，BFS对比

| -    | 数据结构 | 空间   | 优点               |
| ---- | -------- | ------ | ------------------ |
| DFS  | stack    | O(n)   | 不具有”最短路“性质 |
| BFS  | queue    | O(2^n) | 具有“最短路”性质   |

### 树和图的存储

#### 图

> - 有向图：只能 a -> b
>
>   存储：1. 邻接矩阵 （二维矩阵） 2. 邻接表 （单链表）
>
> - 无向图：a -> b, b -> a

#### 树

### 树和图的深度优先遍历

Acwing 846 树的重心

```go
package main

import (
    "fmt"
)
    
const N int = 1e5 + 10

var (
    // n 个链表的链表头
    h = make([]int, N)
    // 每个节点的值-存储所有的边  无向图时需要2倍空间
    e = make([]int, N * 2)
    // 每个节点的 next 指针
    ne = make([]int, N * 2)
    // 表示树的结点数 idx 当前数的下标值
    n, idx int
    // 表示节点的遍历状态
    st = make([]bool, N)
    // 答案-表示重心的所有的子树中最大的子树的结点数目
    ans = N
)

// 插入一条a指向b的边
func add(a, b int) {
    e[idx] = b
    ne[idx] = h[a]
    h[a] = idx
    idx ++
}

// 以u为跟的子树中点的数量
func dfs(u int) int {
    // 标记此节点已经被搜索过了
    st[u] = true
    
    // 连通块数
    sum, res := 1, 0
    
    for i := h[u]; i != -1; i = ne[i] {
        j := e[i]
        // 节点状态不为真，未被遍历过 则遍历
        if st[j] != true {
            // 当前节点的 连通块数
            s := dfs(j)
            res = Max(res, s)
            sum += s
        }
    }
    res = Max(res, n - sum)
    // 返回结果值
    ans = Min(ans, res)
    return sum
}

func Min(x, y int) int {
    if x < y {
        return x
    }
    return y
}

func Max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

func main() {
    
    // 链表初始化，头结点指向-1
    for i := 0; i < N; i ++ {
        h[i] = -1
    }
    
    fmt.Scanf("%d", &n)
    
    for i := 0; i < n; i ++ {
        var a, b int
        fmt.Scanf("%d%d", &a, &b)
        // 无向图，添加两条边
        add(a, b)
        add(b, a)
    }

    // 深度优先遍历，一个点往完了搜索, 起始点并没有限制
    dfs(1)
 
    fmt.Printf("%d", ans)
    
}
```

### 树与图的宽度优先遍历

Acwing 847 图中点的层次

```go
package main

import (
    "fmt"    
    "os"
    "bufio"
)

const N = 1e5 + 10

var (
    n, m int
    // 邻接表参数
    h = make([]int, N)
    e = make([]int, 2 * N)
    ne = make([]int, 2 * N)
    idx int
    // 距离
    d = make([]int, N)
    // 队列
    q = make([]int, N)
)

func bfs() int {
    // 队头，队尾 go中没有用到队头，队尾，所以不写
    
    // 定义队列第一个元素是1
    q[0] = 1;
    
    // 初始化距离数组
    for i := 0; i < N; i ++ {
        d[i] = -1
    }
    
    // 最开始只有第一个点被遍历过了 赋值为0
    d[1] = 0
    
    // bfs框架
    // 队列不空
    for len(q) > 0{
        t := q[0]                           // 取出队头元素
        q = q[1:]                           // 弹出队头元素
        for i := h[t]; i != -1; i = ne[i] { // 扩展当前这个点
            j := e[i]       // j 表示当前到的点
            if d[j] == -1 { // 如果 j 这个点没有被遍历过
                d[j] = d[t] + 1  // 扩展下 j 这个点，到达 j 点的距离
                q = append(q, j) // j 这个点加入到队列
            }
        }
    }
    return d[n]
}

func add(a, b int) {
    e[idx] = b
    ne[idx] = h[a]
    h[a] = idx
    idx ++
}

func main() {
    
    in := bufio.NewReader(os.Stdin)
    
    fmt.Fscan(in, &n, &m)
    
    for i := 0; i < N; i ++ {
        h[i] = -1
    }
    
    for i := 0; i < m; i ++ {
        var a, b int
        fmt.Fscan(in, &a, &b)
        
        add(a, b)
    }
    
    fmt.Println(bfs())
} 
```

### 拓扑排序

图的拓扑序列：图的宽度优先遍历的应用，**无向图没有拓扑序列**

拓扑序列：所有的点都是从前指向后，如果有环，则没有拓扑序列，**有向无环图(拓扑图)一定存在拓扑序列**

入度：有多少条边指向自己

出度：有多少条边从自己出发指向其他节点

> 一个有向无环图，一定至少存在一个入度为0的点
>
> 使用反证法证明，假设一个有向无环图有n个点，从起点开始招，到n + 1个点，由抽屉原理知道，这个图一定存在一个环
>
> *抽屉原理*的一种更一般的表述为： “*把多于kn个东西任意分放进n个空抽屉（k是正整数），那么一定有一个抽屉中放进了至少k+1个东西*。

```go
package main

import "fmt"

const N = 100010

var (
    e [N]int
    ne [N]int
    h [N]int
    idx int
    invec [N]int
    queue [N]int
    n, m int
)

func add(a, b int) {
    e[idx] = b
    ne[idx] = h[a]
    h[a] = idx
    idx++
}

func main() {
    for i := 0; i < N; i++ {
        h[i] = -1
    }

    fmt.Scanf("%d%d", &n, &m)
    for i := 0; i < m; i++ {
        a, b := 0, 0
        fmt.Scanf("%d%d", &a, &b)
        add(a, b)
        invec[b]++
    }

    if !toposort() {
        fmt.Println(-1)
    } else {
        for i := 0; i < n; i++ {
            fmt.Printf("%d ", queue[i])
        }
        fmt.Println("")
    }

}

func toposort() bool {
    hh, tt := 0, -1
    for i := 1; i <= n; i++ {
        if invec[i] == 0 {
            tt++
            queue[tt] = i
        }
    }
    for hh <= tt {
        val := queue[hh]
        hh++
        for i := h[val]; i != -1; i = ne[i] {
            elem := e[i]
            invec[elem]--
            if invec[elem] == 0 {
                tt++
                queue[tt] = elem
            }
        }
    }
    
    // 证明所有点都进入了队列
    return tt == n-1
}
```

### 最短路问题

**n为点数，m为边数**

#### 单源最短路

> 只有一个起点，从一个点到其他所有点的最短距离
>
> - 所有边权都是正数：**{稠密图：用邻接矩阵}朴素Dijkstra算法[O(n^2)]，{稀疏图：用邻接表}堆优化版的Dijkstra算法[O(mlogn)]**
> - 存在负权边:**{个别用}Bellman-Ford[O(nm)], {多用}SPFA[一般O(m)，最坏O(nm)]**

#### 多源汇最短路

> 源点：起点。汇点：终点
>
> 起点和终点都不确定的最短路问题：**弗洛伊德（Floyd）算法，[O(n^3)]**

<img src="D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230207151502403.png" alt="image-20230207151502403" style="zoom:67%;" />

##### 朴素Dijkstra算法

acwing 850. Dijkstra求最短路

```go
package main

import (
    "fmt"    
)

const (
    N = 510
    INF = 0x3f3f3f3f
    // INF = 1<<63 - 1
)

var (
    n, m int
    // 邻接矩阵表示图
    g[N][N]int
    // 当前每个点的巨鹿
    dist = make([]int, N)
    // 当前点的状态
    st = make([]bool, N)
)


func min(a, b int) int {
    if a > b {
        return b
    }
    return a
}

// 迪杰斯特拉算法
func dijkstra() int {
    
    // 初始化距离
    for i := 0; i < N; i ++ {
        dist[i] = INF
    }
    dist[1] = 0
    
    // 遍历所有点 去找最短路
    for i := 0; i < n; i ++ {
        
        t := -1
        for j := 1; j <= n; j ++ {
            // 如果当前这个点还没有被确定最短路 且离源点最近的点
            if !st[j] && (t == -1 || dist[t] > dist[j]) {
                t = j
            }
        }
        
        // 优化  已经找到了最短距离
        if t == n {
            break
        }
        
        // 将t加到状态集合里面去
        st[t] = true
        
        // 使用t这个点去更新其他点的距离
        for j := 1; j <= n; j++ {
            dist[j] = min(dist[j], dist[t]+g[t][j])
        }
    }
    
    // 如果n这个点没有被更新，就说明不存在这个点的最短距离
    if dist[n] == INF {
        return -1
    }
    
    return dist[n]
}

func main() {
    
    // 初始化图数组
    for i := 0; i < N; i ++ {
        for j := 0; j < N; j ++ {
            if i == j {
                g[i][j] = 0
            } else {
                g[i][j] = INF
            }
        }
    }
    
    fmt.Scanf("%d%d", &n, &m)

    for ; m != 0; m -- {
        var a, b, c int        
        fmt.Scanf("%d%d%d", &a, &b, &c)
        
        // 只保留长度最小的这条边
        g[a][b] = min(g[a][b], c)
    }
    
    fmt.Println(dijkstra())
    
}
```

##### 堆优化Dijkstra算法

```go
package main

import (
    "bufio"
    "container/heap"
    "fmt"
    "os"
    "strconv"
    "strings"
)

const N int = 1e6 + 10

var (
    h    [N]int
    e    [N]int
    ne   [N]int
    idx  int
    w    [N]int
    dist [N]int
    n, m int
    st   [N]bool
)

func add(a, b, c int) {
    e[idx] = b
    ne[idx] = h[a]
    w[idx] = c
    h[a] = idx
    idx++
}
func readline(r *bufio.Reader) []int {
    s, _ := r.ReadString('\n')
    ss := strings.Fields(s)
    res := make([]int, len(ss))
    for i, v := range ss {
        res[i], _ = strconv.Atoi(v)
    }
    return res
}
func dijkstra() int {
    for i := 0; i < N; i++ {
        dist[i] = 0x3f3f3f3f
    }
    dist[1] = 0
    // 堆优化
    var q PriorityQueue
//  q :=make(PriorityQueue,0,n)
    heap.Push(&q, &pair{first: 0, second: 1})

    for q.Len() > 0 {
        t := heap.Pop(&q)
        if v, ok := t.(*pair); ok {
            distance := v.first
            ver := v.second

            if st[ver]{
                continue
            }
            st[ver] = true
            for i := h[ver]; i != -1; i = ne[i] {
                j := e[i]
                if dist[j] > distance+w[i] {
                    dist[j] = distance + w[i]
                    heap.Push(&q, &pair{first: dist[j], second: j})
                }
            }
        }
    }
    if dist[n] == 0x3f3f3f3f {
        return -1
    }
    return dist[n]

}

//采用自带的堆heap,要实现若干接口
type pair struct {
    first  int
    second int
}
type PriorityQueue []*pair

func (pq *PriorityQueue) Push(x interface{}) {
    if v, ok := x.(*pair); ok {
        *pq = append(*pq, v)
    }
}
func (pq *PriorityQueue) Pop() interface{} {
    n := len(*pq)
    x := (*pq)[n-1]
    *pq = (*pq)[:n-1]
    return x
}
func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}
func (pq PriorityQueue) Len() int {
    return len(pq)
}
func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].first < pq[j].first
}
func main() {
    fmt.Scanf("%d%d", &n, &m)
    for i := 0; i < N; i++ {
        h[i] = -1
    }
    r := bufio.NewReader(os.Stdin)
    for m > 0 {
        m--
        in := readline(r)
        a, b, z := in[0], in[1], in[2]
        add(a, b, z)
    }
    fmt.Println(dijkstra())
}
```

##### Bellman-fold 算法



##### SPFA 算法

acwing 851

```go
package main

import (
    "fmt"
    "bufio"
    "os"
    "strconv"
    "strings"

)

const N = 100010

// 根据数据范围，可以看出来要用邻接表来存储
var (
    he, el, ne, we []int // 分别存储邻接表的头结点、节点元素值、节点的后继位置、节点的权重
    index int // 指示邻接表的数组模拟存储到了什么位置
    dist []int // dist 数组
    n, m int // 图中的点数与边数
    checked []bool // 标识节点有没有被加入路径过
)

func Init() {
    he = make([]int, N)
    ne = make([]int, N)
    el = make([]int, N)
    we = make([]int, N)
    dist = make([]int, N)
    checked = make([]bool, N)
    index = 1
    for i := 0; i < N; i++ {
        dist[i] = 0x3f3f3f3f
    }
}

func main() {
    Init()
    sc := bufio.NewScanner(os.Stdin)
    sc.Scan()
    line := strings.Split(sc.Text(), " ")
    n, _ = strconv.Atoi(line[0])
    m, _ = strconv.Atoi(line[1])

    for i := 0; i < m; i++ {
        sc.Scan()
        line = strings.Split(sc.Text(), " ")
        x, _ := strconv.Atoi(line[0]) 
        y, _ := strconv.Atoi(line[1]) 
        z, _ := strconv.Atoi(line[2])
        insert(x, y, z)
    }

    t := spfa()
    if t == 0x3f3f3f3f {
        fmt.Println("impossible")
    } else {
        fmt.Println(t)
    }

}

func insert(x, y, z int) {
    el[index] = y
    ne[index] = he[x]
    he[x] = index
    we[index] = z
    index++
}

func spfa() int {

    // 自定义一个队列来进行存储
    queue := make([]int, N)
    head, tail := 0, 0 // 队头与队尾的指针

    dist[1] = 0
    checked[1] = true
    // 节点 1 入队
    queue[tail] = 1
    tail++
    // 队非空的时候进行循环
    for tail > head {
        // 元素出队
        t := queue[head]
        head++
        checked[t] = false
        // 从 t 能到达的所有点，更新
        for i := he[t]; i != 0; i = ne[i] {
            j := el[i] // 这是哪个点
            if dist[j] > dist[t] + we[i] {
                // 更新
                dist[j] = dist[t] + we[i]
                // 将没出过的点加入队列
                if !checked[j] {
                    // 入队
                    queue[tail] = j
                    tail++
                    checked[j] = true
                }
            }
        }
    }
    return dist[n]
}
```

acwing 852 spfa 求负环

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)

var scanner *bufio.Scanner

func readline() []int{
    scanner.Scan()
    l := strings.Split(scanner.Text(), " ")

    res := make([]int, len(l))
    for i, s := range l {
        x, _ := strconv.Atoi(s)
        res[i] = x
    }
    return res
}

var n, m int
const N = 100010
var e, ne, h, w [N]int
var idx int
var dist, cnt [N]int
var st [N]bool

func add(a, b, c int){
    e[idx] = b
    w[idx] = c
    ne[idx] = h[a]
    h[a] = idx
    idx ++
}

func spfa() bool{

    q := make([]int, 0)
    q = append(q, 1)
    for i:=1; i<=n; i++{
        q = append(q, i) // 因为这个负环不一定是从1号点开始的，所以要把所有的点都加进queue中
        st[i] = true
    }
    for len(q) > 0{ // 对于a->b来说，只有a变小了，b才有可能变小，所以在queue中存放所有dist变小了的点
                    // 然后对于拿出来的点i，将它所有的出点遍历，如果变小了，再看它是否不在queue中（用st数组）
                    // 如果不在的话，再放入queue中。
        t := q[0]
        q = q[1:]
        st[t] = false

        for i:=h[t]; i!=-1; i=ne[i]{
            j := e[i]
            if dist[j] > dist[t] + w[i]{
                dist[j] = dist[t] + w[i]
                cnt[j] = cnt[t] + 1 // 记录如果从t号点更新的话，边数也要加一
                if cnt[j] >= n{
                    return true
                }
                if !st[j]{
                    q = append(q, j)
                    st[j] = true
                }
            }
        }
    }
    return false
}

func main(){
    scanner = bufio.NewScanner(os.Stdin)
    bs := make([]byte, 20000*1024)
    scanner.Buffer(bs, len(bs))

    for i:=0; i<N; i++{
        h[i] = -1
    }

    fmt.Scanf("%d%d", &n, &m)
    for i:=0; i<m; i++{
        x := readline()
        a, b, c := x[0], x[1], x[2]
        add(a, b, c)
    }
    if spfa(){
        fmt.Println("Yes")
    } else {
        fmt.Println("No")
    }
}
```

##### Floyd 算法

```go
package main

import "fmt"

const (
    N = 210
    INF = 1e9
)

var (
    n, m, Q int
    d[N][N] int
)

func main() {
    
    fmt.Scanf("%d%d%d", &n, &m, &Q)
    
    // 初始化邻接矩阵
    for i := 1; i <= n ; i ++ {
        for j := 1; j <= n; j ++ {
            if i == j {
                d[i][j] = 0
            } else {
                d[i][j] = INF
            }
        }
    }
    
    for ;m != 0; m -- {
        var a, b, w int
        fmt.Scanf("%d%d%d", &a, &b, &w)
        
        d[a][b] = min(d[a][b], w)
    }
    
    floyd()
    
    // 处理询问
    for ; Q != 0; Q -- {
        var a, b int
        
        fmt.Scanf("%d%d", &a, &b)
        
        // 避免存在负权边，比INF小的问题
        if d[a][b] > INF / 2 {
            fmt.Println("impossible")  
        } else {
            fmt.Println(d[a][b])
        }
    }
    
}

func floyd() {
    for k := 1; k <= n; k ++ {
        for i := 1; i <= n; i ++ {
            for j := 1; j <= n ; j ++ {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j])
            }
        }
    }
}

func min(a, b int) int {
    
    if (a > b) {
        return b
    }
    
    return a
    
}
```

### 最小生成树

稀疏图：克鲁斯卡尔算法

稠密图：朴素普利姆算法，堆优化版不常用

<img src="D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230208203901992.png" alt="image-20230208203901992" style="zoom: 67%;" />

##### 朴素Prim

```go
package main

import "fmt"

const N = 510
const INF = 0x3f3f3f3f

var g [N][N]int
var st [N]bool
var dist [N]int
var n, m int

func main() {

    //init graph N*N inf
    for i := 0; i < N; i++ {
        for j := 0; j < N; j++ {
            g[i][j] = INF
        }
    }

    fmt.Scanf("%d%d", &n, &m)

    for ; m > 0; m-- {
        a, b, c := 0, 0, 0
        fmt.Scanf("%d%d%d", &a, &b, &c)
        g[a][b] = min(g[a][b], c)
        g[b][a] = min(g[a][b], c)
    }

    t := prim()
    if t == INF {
        fmt.Println("impossible")
    } else {
        fmt.Println(t)
    }

}

func min(a, b int) int {
    if a <= b {
        return a
    }
    return b

}

func prim() int {
    for i := 0; i < N; i++ {
        dist[i] = 0x3f3f3f3f
    }
    res := 0

    for i := 0; i < n; i++ {
        t := -1
        for j := 1; j <= n; j++ {
            if !st[j] && (t == -1 || dist[t] > dist[j]) {
                t = j
            }

        }

        if i > 0 && dist[t] == INF {
            return INF
        }

        st[t] = true
        if i > 0 {
            res += dist[t]
        }

        for j := 1; j <= n; j++ {
            dist[j] = min(dist[j], g[t][j])
        }

    }
    return res

}
```

##### 克鲁斯卡尔

> 1. 将所有边按**权重**从小到大排序 O(mlogn)
>
> 2. 枚举每条边，a ——> b 权重c
>
>    如果不连通，则将这条边加入到集合中去

```go
package main

import (
    "fmt"
    "sort"
)

//INF
const INF = 0x3f3f3f3f

//Edge matrix
type Edge struct {
    A int
    B int
    W int
}

const N = 100010
const M = 200010

var n, m int
var p [N]int

//Kruskal function
func Kruskal(edges []*Edge) int {
    
    // 排序
    sort.SliceStable(edges, func(i, j int) bool {
        return edges[i].W < edges[j].W
    })

    // 初始化并查集
    for i := 1; i <= n; i++ {
        p[i] = i
    }

    res, cnt := 0, 0
    for i := 0; i < m; i++ {
        a := edges[i].A
        b := edges[i].B
        w := edges[i].W
        a = find(a)
        b = find(b)
        if a != b {
            p[a] = b
            res += w
            cnt++
        }
    }

    // 小于 n - 1 说明连通
    if cnt < n-1 {
        return INF
    }

    return res
}

// 并查集中的find函数
func find(x int) int {
    if p[x] != x {
        p[x] = find(p[x])
    }
    return p[x]
}

func main() {
    edges := make([]*Edge, 0)
    fmt.Scanf("%d%d", &n, &m)
    for i := 0; i < m; i++ {
        a, b, w := 0, 0, 0
        fmt.Scanf("%d%d%d", &a, &b, &w)
        edges = append(edges, &Edge{a, b, w})
    }

    t := Kruskal(edges)
    if t == INF {
        fmt.Println("impossible")
    } else {
        fmt.Println(t)
    }
}
```

### 二分图

![image-20230208204051196](D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230208204051196.png)

**二分图：将所有的点划分到两边去。性质：当且仅当图中不含奇数环**

#### 染色法

acwing 860

> 判断一个图是不是二分图，将图中的点染成两种颜色。
>
> 使用深度优先或者宽度优先遍历每个点

```go
package main

import (
    "fmt"
    "os"
    "bufio"
)

const (
    N = 1e5 + 10
    // 无向图需要两条边
    M = 2e5 + 10
)

var (
    n, m int
    
    // 邻接表
    h[N] int
    e[M] int
    ne[M] int
    idx int
    
    // 染色记录
    color[N] int
)

// 添加图的边
func add(a, b int) {
    
    idx ++
    e[idx] = b
    ne[idx] = h[a]
    h[a] = idx
}

func dfs(u, c int) bool {
    
    // 记录当前点的颜色
    color[u] = c
    
    for i := h[u]; i != -1; i = ne[i] {
        // 存储当前点的编号
        j := e[i]
        // 如果当前点没有被染色
        if color[j] == 0 {
            // 染色：1染成2，2染成1 用3-c
            if !dfs(j, 3 - c) {
                return false
            }
        // 如果当前点已经有颜色了，则出现矛盾    
        } else if color[j] == c {
            return false
        }
    }
    
    return true
}

func main() {
    
    // 避免TLE
    in := bufio.NewReader(os.Stdin)
    
    fmt.Fscan(in, &n, &m)
    
    // 初始化邻接矩阵 存储图
    for i := 0; i < N; i ++ {
        h[i] = -1
    }
    
    // 读入图
    for ; m != 0; m -- {
        var a, b int
        fmt.Fscan(in, &a, &b)
        add(a, b)
        add(b, a)
    }
    
    // 标记值，标记在染色过程中是否有矛盾发生
    flag := true
    // 开始染色
    for i := 0; i < N; i ++ {
        // c++ 中if语句可以是数字，非0数字为真，0为假
        if color[i] == 0 {
            // 如果dfs返回false，我们认为就有矛盾发生
            // 这里是把i点染成第一种颜色 (1)
            if !dfs(i, 1) {
                flag = false
                break
            }
        }
    }
    
    // 如果染色过程完美，没有矛盾发生，则是二分图
    if flag {
        fmt.Println("Yes")
    } else {
        // 有矛盾则不是
        fmt.Println("No")
    }
    
}
```

#### 匈牙利算法

> 不断尝试去匹配
>
> 先试着匹配一对，如果后面的匹配被抢了，看看前面的匹配能不能让步，这个模式可以复用

Acwing 862

```go
package main

import (
    "fmt"
    "os"
    "bufio"
)

const (
    N = 500 + 10    
    M = 1e5 + 10
)

var (
    n1, n2, m int
    // 邻接表
    // e[i] 表示节点 i 的值
    // ne[i] 表示节点i的next指针是多少
    // idx 存储当前已经用到的那个点
    h[N] int
    e[M] int
    ne[M] int
    idx int
    
    // 右边的点对应的点
    match[N] int
    // 状态值
    st[N] bool
)

func add(a, b int) {
    e[idx] = b
    ne[idx] = h[a]
    h[a] = idx
    idx ++
}

// 查找所有点
func find(x int) bool {
    
    for i := h[x] ; i != -1; i = ne[i] {
        // 表示当前集合点的编号
        j := e[i]
        // 是否已经考虑过了
        if !st[j] {
            st[j] = true
            if match[j] == 0 || find(match[j]) {
                match[j] = x
                return true
            }
        }
    }
    
    return false
}

func main() {
    
    in := bufio.NewReader(os.Stdin)
    
    fmt.Fscan(in, &n1, &n2, &m)
    
    // 初始化邻接矩阵
    for i := 0 ; i < N; i ++ {
        h[i] = -1
    }
    
    // 读入图
    for ; m != 0; m -- {
        var a, b int
        fmt.Fscan(in, &a, &b)
        add(a, b)
    }
    
    // res 存的是当前匹配点的数量
    res := 0
    for i := 1; i <= n1; i ++ {
        // 清空所有连接
        for j := 0; j < N; j ++ {
            st[j] = false
        }
        // 匹配到，则+1
        if find(i) {
            res ++
        }
    }
    
    // 输出
    fmt.Println(res)
    
}
```

## 第四讲

### 数论

#### 质数

> 在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数或者素数
>
> 质数判定 **（性质：如果 d/n 那么 n/d/n）**即只枚举到根号n即可
>
> <img src="D:\information\Typora笔记\数据结构和算法\算法模板1.assets\image-20230214155051627.png" alt="image-20230214155051627" style="zoom:50%;" />
>
> 1. 质数判定 O(sqrt(n)
>
>    ```go
>    func isPrime(n int) bool {
>        flag := true
>        if n < 2 {
>            return false
>        }
>        for i := 2; i <= n / i; i ++ {
>            if n % i == 0 {
>                flag = false
>            }
>        }
>        return flag
>    }
>    ```
>
> 2. 分解质因数 O(logn) ~ O(sqrt(n)
>
>    ```go
>    func divide(n int) {
>    	
>        // 从小到大尝试n的所有因数
>        for i := 2; i <= n / i; i ++ {
>            if n % i == 0 {
>                // 证明是一个质数之后再分解
>                s := 0
>                for n % i == 0 {
>                    n /= i
>                    s ++
>                }
>                fmt.Printf("%d %d\n", i, s)
>            }
>        }
>        
>        // 输出自己
>        if n > 1 {
>            fmt.Printf("%d %d\n", n, 1)
>        }
>        
>        fmt.Println()
>    }
>    ```
>
> 3. 筛质数 O(nlogn)
>
>    ```go
>    // 从大于1的数n开始，往后遍历，删掉n的倍数
>    package main
>          
>    import "fmt"
>          
>    const N = 1e6 + 10
>          
>    var (
>        n, cnt int
>        primes[N] int
>        st[N] bool
>    )
>          
>    // 朴素筛法
>    func getPrimes(n int) {
>              
>        for i := 2; i <= n; i ++ {
>            // 如果当前数没有被筛过，则是质数
>            if !st[i] {
>                cnt ++
>                primes[cnt] = n
>            }
>                  
>            // 删除倍数
>            for j := i + i; j <= n; j += i {
>                st[j] = true
>            }
>        }
>    }
>          
>    // 埃氏筛法 O(nloglogn)
>    func getPrimesPlus(n int) {
>              
>        for i := 2; i <= n; i ++ {
>            // 如果当前数没有被筛过，则是质数
>            if !st[i] {
>                cnt ++
>                primes[cnt] = n
>                      
>                // 删除倍数
>    	        for j := i + i; j <= n; j += i {
>                	st[j] = true
>            	}
>            }
>        }
>    }
>          
>    // 线性筛法 n只会被最小质因子筛掉
>    func getPrimesPlus1(n int) {
>              
>        for i := 2; i <= n; i++ {
>            if !st[i] {
>                primes[cnt] = i
>                cnt++
>            }
>          
>            for j := 0; primes[j] <= n/i; j++ {
>                st[primes[j]*i] = true
>                if i%primes[j] == 0 {
>                    break
>                }
>            }
>        }
>    }
>          
>    func main() {
>              
>        var n int
>        fmt.Scanf("%d", &n)
>              
>        getPrimes(n)
>              
>        fmt.Println(cnt)
>              
>    }
>    ```

#### 约数

1. 试除法求一个数的约数 O(sqrt(n))

   ```go
   package main
   
   import (
       "fmt"
       "sort"
   )
   
   func getDivisors(n int) []int {
       
       s := []int{}
       
       // 降低时间复杂度
       for i := 1; i <= n / i; i ++ {
           if n % i == 0 {
               s = append(s, i)
               if i != n / i {
                   s = append(s, n / i)
               }
           }
       }
       
       return s
   }
   
   func main() {
       var n int
       
       fmt.Scanf("%d", &n)
       
       for ; n != 0; n -- {
           var x int
           fmt.Scanf("%d", &x)
           res := getDivisors(x)
           
           // 排序
           sort.Ints(res)
           
           for i := 0; i < len(res); i ++{
               fmt.Printf("%d ", res[i])
           }
           
           fmt.Println()
       }
       
   }
   ```

2. 约数之和

   ```go
   package main
   
   import "fmt"
   
   const mod = 1000000007
   var mp map[int]int
   
   func p_prime(n int) {
       for i:=2; i<=n/i; i++{
           for n%i == 0{
               mp[i]++
               n /= i
           }
       }
       if n>1{
           mp[n] ++
       }
   }
   
   func main(){
       var n, m int
       fmt.Scanf("%d", &n)
       res := 1
       mp = make(map[int]int, 0)
       for n>0{
           n--
           fmt.Scanf("%d", &m)
           p_prime(m)
       }
       for k, v := range mp{
           t := 1
           for v > 0{
               v--
               t = (t * k + 1) % mod
           }
           res = res * t % mod
       }
       fmt.Println(res)
   }
   ```

3. 约数个数

   ```go
   package main
   
   import "fmt"
   
   const mod = 1000000007
   var mp map[int]int
   
   func p_prime(n int) {
       for i:=2; i<=n/i; i++{
           for n%i == 0{
               mp[i]++
               n /= i
           }
       }
       if n>1{
           mp[n] ++
       }
   }
   
   func main(){
       var n, m int
       fmt.Scanf("%d", &n)
       res := 1
       mp = make(map[int]int, 0)
       for n>0{
           n--
           fmt.Scanf("%d", &m)
           p_prime(m)
       }
       for _, v := range mp{
           res = res * (v + 1) % mod
       }
       fmt.Println(res)
   }
   ```

4. 最大公约数 欧几里得算法 辗转相除法

   ```go
   package main
   
   import (
       "fmt"
       "os"
       "bufio"
   )
   
   func gcd(a, b int) int {
       
       if b > 0 {
           return gcd(b, a % b)
       } 
       
       return a
   }
   
   func main() {
       
       in := bufio.NewReader(os.Stdin)
       
       var n int
       fmt.Fscan(in, &n)
       
       for ; n != 0; n -- {
           var a, b int
           fmt.Fscan(in, &a, &b)
           
           res := gcd(a, b)
           
           fmt.Println(res)
       }
       
   }
   ```

5. 欧拉函数 acwing 873

   > ![image-20230215164141623](D:\information\Typora笔记\学习笔记\算法模板\算法模板1.assets\image-20230215164141623.png)
   >
   > 使用容斥原理证明

   ```go
   package main
   
   import "fmt"
   
   func main() {
       var n int
       
       fmt.Scanf("%d", &n)
       
       for ; n != 0; n -- {
               
           var a int
           fmt.Scanf("%d", &a)
           
           res := a
               
           for i := 2; i <= a / i; i ++ {
               if a % i == 0 {
                   // 这样处理是为了避免出现小数
                   res = res / i * (i - 1)
                   
                   // go的while写法
                   for a % i == 0 {
                       a /= i
                   }
               }
           }
           
           if a > 1 {
               res = res / a * (a - 1)
           }
           
           fmt.Println(res)
       }
       
   }
   ```

   ```go
   // 筛法求欧拉函数
   package main
   
   import "fmt"
   
   const N int = 1e6 + 10
   
   var (
       // primes, phi [N]int
       // 质数数组 下标
       primes[N] int
       cnt int
       // 欧拉函数数组
       phi[N] int
       // 状态数组 当前数是否被判断过了
       st[N] bool
   )
   
   func getEulers(n int) int64 {
       
       phi[1] = 1
       
       for i := 2; i <= n; i ++ {
           // 如果当前数没有被筛过就是质数
           if !st[i] {
               primes[cnt] = i
               cnt ++
               
               phi[i] = i - 1
           }
           
           for j := 0; primes[j] <= n / i; j ++ {
               // 筛去倍数
               st[primes[j] * i] = true
               if i % primes[j] == 0 {
                   
                   phi[primes[j] * i] = phi[i] * primes[j]
                   
                   break
               }
               
               phi[primes[j] * i]  = phi[i] * (primes[j] - 1)
           }
       }
       
       var res int64 = 0
       for i := 1; i <= n; i ++ {
           res += int64(phi[i])
       }
       
       return res
   }
   
   func main() {
       var n int
       fmt.Scanf("%d", &n)
       
       fmt.Println(getEulers(n))
   }
   ```

6. 快速幂 acwing 875

   ```go
   package main
   
   import (
       "fmt"
       "os"
       "bufio"
   )
   
   // 快速幂
   func qmi(a, k, p int64) int64 {
       
       var res int64 = 1
       
       for k > 0 {
           if k & 1 > 0 {
               res = (res * a) % p
           }
           
           k >>= 1
           a = (a * a) % p
       }
       
       return res
   }
   
   func main() {
       
       in := bufio.NewReader(os.Stdin)
       out := bufio.NewWriter(os.Stdout)
       
       var n int
       fmt.Fscan(in, &n)
       
       for i := 0; i < n; i ++ {
           var a, k, p int64
           
           fmt.Fscan(in, &a, &k, &p)
           
           fmt.Fprintln(out, qmi(a, k, p))
           
           out.Flush()
       }
       
   }
   ```

7. 扩展欧几里得算法

   > 裴蜀定理：
   >
   > 对于任意的正整数a，b, 一定存在整数 x y。使得
   >
   > `ax + by = (a, b)`
   >
   > (a, b) 的最大公约数的倍数

   ```go
   package main
   
   import (
   	"fmt"
       "os"
       "bufio"
   )
   
   var (
       n, a, b, x, y int
       in = bufio.NewReader(os.Stdin)
       writer = bufio.NewWriter(os.Stdout)
   )
   
   func exgcd(a, b int) (int, int, int) {
       
       if b == 0 {
           x = 1
           y = 0
           return a, x, y
       }
       
       // 这个交换x, y位置主要是让y系数保持是b
       d, y, x := exgcd(b, a % b)
       
       y = y - (a / b * x)
       
       return d, x, y
   }
   
   func main() {
       fmt.Scanf("%d", &n)
       
       for ; n > 0; n -- {
           fmt.Fscan(in, &a, &b)
           
           _, x, y := exgcd(a, b)
           
           fmt.Printf("%d %d\n", x, y)
       }
   }
   ```

8. 中国剩余定理

   ```go
   package main
   import "fmt"
   type LL int64
   
   // 扩展欧几里得算法
   func exgcd(a, b LL) (LL, LL, LL){
       if b == 0 {
           return a, 1, 0
       }
   
       d, y, x := exgcd(b, a % b)
       return d, x, y - a/b * x
   }
   
   // 绝对值
   func abs(a LL) LL {
       if a >= 0 {
           return a
       }
   
       return -a
   } 
   
   func main(){
       var(
           n int
           a1 LL
           m1 LL
       )
   
       fmt.Scanf("%d", &n)
       fmt.Scanf("%d%d", &a1, &m1)
       flag := true
   
       for i := 0; i < n - 1; i ++ {
           var a2, m2 LL
           fmt.Scanf("%d%d", &a2, &m2)
   
           d, k1, _ := exgcd(a1, a2)
           if ((m2 - m1) % d != 0) {   // 检查欧几里得是否有效
               flag = false
               break
           }
   
           k1 *= (m2 - m1) / d   // 将d变为(m2-m1), 扩大系数为(m2 - m1) / d倍
           t := a2 / d
           k1 = (k1 % t + t) % t // 取解的通式最小的k1，避免中间过程溢出
   
           // 更新x = ka + m
           m1 = k1 * a1 + m1
           a1 = abs(a1 / d * a2)
       }
   
       if flag {
           fmt.Println((m1 % a1 + a1) % a1)
       }else{
           fmt.Println(-1)
       }
   }
   ```

### 组合计数

1. Acwing 885

   ```go
   package main
   
   import "fmt"
   
   const (
       N int = 2010
       mod = 1e9 + 7
   )
   
   var c[N][N]int
   
   func init() {
       
       for i := 0; i < N; i ++ {
           for j := 0; j <= i; j ++ {
               if j == 0 {
                   c[i][j] = 1
               } else {
                   c[i][j] = (c[i - 1][j] + c[i- 1][j - 1]) % mod
               }
           }
       }
       
   }
   
   func main() {
       
       var n int
       fmt.Scanf("%d", &n)
       
       for ; n != 0; n -- {
           var a, b int
           fmt.Scanf("%d%d", &a, &b)
           
           fmt.Printf("%d\n", c[a][b])
       }
       
   }
   ```

2. acwing 886

   ```go
   package main
   
   import (
       "fmt"
       "os"
       "bufio"
   )
   
   const (
       N int = 1e5 + 10
       mod int64 = 1e9 + 7
   )
   
   var (
       
       in = bufio.NewReader(os.Stdin)
       
       // 阶乘模的值
       fact[N] int64
       // 逆元阶乘模值
       infact[N] int64
   )
   
   // 求逆元
   func qmi(a, k, p int64) int64 {
       var res int64 = 1
       for k > 0 {
           if k & 1 == 1 {
               res = res * a % p
           }
           
           a = a * a % p
           k >>= 1
       }
       
       return res
   }
   
   func main() {
    
       fact[0], infact[0] = 1, 1
       
       for i := 1; i < N; i ++ {
           fact[i] = fact[i - 1] * int64(i) % mod
           infact[i] = infact[i - 1] * qmi(int64(i), mod - 2, mod) % mod
       }
       
       var n int
       fmt.Fscan(in, &n)
       
       for i := 0; i < n; i ++ {
           
           var a, b int64
           
           fmt.Fscan(in, &a, &b)
           
           fmt.Println(fact[a] * infact[b] % mod * infact[a - b] % mod)
       }
       
   }
   ```

3. acwing 887

   ```go
   package main
   
   import (
       "bufio"
       "fmt"
       "os"
   )
   
   var (
       p int
   )
   
   func qmi(a, k, p int) int {
   
       res := 1
       for k != 0 {
           if k&1 == 1 {
               res = res * a % p
           }
           k >>= 1
           a = a * a % p
       }
       return res
   }
   
   // 按定义求C(a,b)
   func C(a, b int) int {
   
       res := 1
       for i, j := 1, a; i <= b; i, j = i+1, j-1 {
           res = res * j % p
           res = res * qmi(i, p-2, p)%p
       }
       return res
   }
   
   // lucas 公式
   func Lucas(a, b int) int {
   
       if a < p && b < p {
           return C(a, b)
       } else {
           return C(a%p, b%p) * Lucas(a/p, b/p) % p
       }
   }
   
   func main() {
   
       in := bufio.NewReader(os.Stdin)
       var n int
       fmt.Fscanln(in, &n)
   
       var a, b int
       for n > 0 {
           n--
   
           fmt.Fscanln(in, &a, &b, &p)
           fmt.Println(Lucas(a, b))
       }
   }
   ```

4. acwing 888

   ```go
   package main
   
   import"fmt"
   
   const N int = 5010
   
   var(
       cnt int
       sum,primes[N]int
       st[N]bool
   )
   
   func getprimes(n int){
       for i:=2;i<=n;i++{
           if!st[i]{
               primes[cnt]=i;
               cnt++
           }
           for j:=0;primes[j]<=n/i;j++{
               st[primes[j]*i]=true;
               if primes[j]%i==0{
                   break
               }
           }
       }
   }
   
   func get(n,p int)int{
       res:=0
       for n!=0{
           res+=n/p
           n/=p
       }
       return res
   }
   
   func mul(a[]int,b int)[]int{
       c:=[]int{}
       t:=0
       for i:=0;i<len(a);i++{
           t+=a[i]*b
           c=append(c,t%10)
           t/=10
       }
       for t!=0{
           c=append(c,t%10)
           t/=10
       }
       return c
   }
   
   func main(){
       a:=0
       b:=0
       fmt.Scanf("%d%d",&a,&b)
       getprimes(a)
       for i:=0;i<cnt;i++{
           p:=primes[i]
           sum[i]=get(a,p)-get(a-b,p)-get(b,p)
       }
       res:=[]int{}
       res=append(res,1)
       for i:=0;i<cnt;i++{
           for j:=0;j<sum[i];j++{
               res=mul(res,primes[i])
           }
       }
       for i:=len(res)-1;i>=0;i--{
           fmt.Printf("%d",res[i])
       }
   }
   ```

5. acwing 889

   > 卡特兰数：
   >
   > <img src="D:\information\Typora笔记\学习笔记\算法模板\算法模板1.assets\image-20230216181630315.png" alt="image-20230216181630315" style="zoom:67%;" />

```go
```





### 高斯消元

1. acwing 883. 高斯消元解线性方程组

   > <img src="D:\information\Typora笔记\学习笔记\算法模板\算法模板1.assets\image-20230216155332861.png" alt="image-20230216155332861" style="zoom:50%;" />

   ```go
   package main
   
   import (
       "fmt"    
       "os"
       "bufio"
       "math"
   )
   
   const (
       N int = 110
       // 因为c++原因 避免浮点数出错，当float64数字足够小于某个值时，我们就认为这个数等于0了
       eps float64 = 1e-6
   )
   
   var (
       n int
       a[N][N] float64
       
       in = bufio.NewReader(os.Stdin)
       out = bufio.NewWriter(os.Stdout)
   )
   
   func swap(list *[N][N]float64, x1, y1, x2, y2 int) {
       (*list)[x1][y1], (*list)[x2][y2] = (*list)[x2][y2], (*list)[x1][y1]
   }
   
   func gauss() int {
       
       // c 表示 枚举的那一列，r表示枚举的那一行
       var c, r int
       
       // 从第零行第零列开始枚举
       for c, r = 0, 0; c < n; c ++ {
           t := r
           for i := r; i < n; i ++ {
               // 找到绝对值最大的一行
               if math.Abs(a[t][c]) < math.Abs(a[i][c]) {
                   t = i
               }
           }
           
           if math.Abs(a[t][c]) < eps {
               continue
           } 
           
           for i := 0; i <= n; i ++ {
               swap(&a, t, i, r, i)
           }
           
           for i := n; i >= c; i -- {
               a[r][i] /= a[r][c]
           }
           
           for i := r + 1; i < n; i ++ {
               if math.Abs(a[i][c]) > eps {
                   for j := n; j >= c; j -- {
                       a[i][j] -= a[r][j] * a[i][c]
                   }
               }
           }
           
           r ++
       }
       
       if r < n {
           for i := r; i < n; i ++ {
               // 0 == a[i][n]非零
               if math.Abs(a[i][n]) > eps {
                   // 无解
                   return 2
               }
           }
           // 无穷多解
           return 1
       }
       
       
       for i := n - 1; i >= 0; i -- {
           for j := i + 1; j < n; j ++ {
               a[i][n] -= a[i][j] * a[j][n]
           }
       }
       
       // 有唯一解
       return 0
       
   }
   
   func main() {
       
       fmt.Fscan(in, &n)
       for i := 0; i < n; i ++ {
           for j := 0; j < n + 1; j ++ {
               fmt.Fscan(in, &a[i][j])
           }
       }
       
       res := gauss1()
       
       if res == 0 {
           for i := 0; i < n; i ++ {
               fmt.Printf("%.2f\n", a[i][n])
           }
       } else if res == 1 {
           fmt.Println("Infinite group solutions")
       } else {
           fmt.Println("No solution")
       }
       
       
   }
   ```

2. acwing 884 

   ```go
   
   ```

### 简单博弈论

