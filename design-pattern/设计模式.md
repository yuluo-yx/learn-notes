# 设计模式

软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

> 肯特·贝克和[沃德·坎宁安](https://baike.baidu.com/item/沃德·坎宁安/6488429)在1987年利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口的生成中。一年后Erich Gamma在他的[苏黎世大学](https://baike.baidu.com/item/苏黎世大学/1621125)博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991 年也在利用相同的思想致力于C的开发，而后于1991年发表了他的著作Advanced C Idioms。就在这一年Erich Gamma 得到了博士学位，然后去了美国，在那与Richard Helm, Ralph Johnson ,John Vlissides合作出版了Design Patterns - Elements of Reusable Object-Oriented Software 一书，在此书中共收录了23个设计模式。这四位作者在软件开发领域里也以他们的匿名著称Gang of Four(四人帮，简称GoF),并且是他们在此书中的协作导致了软件设计模式的突破。

进行软件开发的时候，不仅仅需要完成最基本的业务功能，还要考虑整个项目的可维护性和可复用性，来自耦合性、内聚性在编写代码时，应该尽可能的规范，随着项目的扩大，项目的整体结构不至于越来越糟。是程序呈现出**高内聚、低耦合**的特性！

## 面向对象七大设计模式原则

设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据。）

### 单一职责原则

（Simple Responsibility Pinciple） SRP：最简单的面向对象设计原则，用于控制类的粒度大小

> 一个对象应该只包含单一的职责，并且该职责被完整的封装到一个类中。

在设计mapper、service、controller等，根据不同的业务进行划分，都可以使用单一职责原则，以它作为我们高内聚低耦合的指导方针。微服务也参考了单一职责原则，每个微服务只承担一个职责。

> 单一职责原则注意事项和细节
>
> - 降低类的复杂度，一个类只负责一项职责
> - 提高类的可读性和可维护性
> - 降低变更引起的风险
> - 通常情况下，我们应该遵守的单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有在类中方法数量足够少时，可以在方法级别保持单一职责原则。

### 开闭原则（最重要，最基础的设计原则）

Open close Principle：一个软件实体，比如类，模块和函数应该对扩展（提供方）开放。其中，对扩展开放是针对提供方来说的，对修改关闭是对调用方来说的。

> 软件实体应对扩展开放，对修改关闭

举个例子：

​		我们的程序员分为Java程序员，C#程序员，C++程序员，前端程序员等，他们要做的就是去打代码，具体如何打代码是由不同语言的程序员来决定的，我们可以将程序员打代码这个行为抽象成为一个统一的接口或者是抽象类，这样我们就满足了开闭原则的第一个要求，对扩展开放，不同的程序员可以自由决定他们该如何进行编程。而具体那个程序员使用什么语言怎么编程是自己在负责，不需要其他程序员干涉，所以满足第二个要求，对修改关闭。

例如：

```java
public abstract void Coder {
    
    public abstract coid coding();
    
    class JavaCoder extends Coder {
        @Override
        public void coding() {
            System.out.println("Java 太卷了，都去学go吧！");
        }
    }
    
    class PHPCoder extends Coder() {
        @Override
        public void coding() {
            System.out.println("PHP是世界上最好的语言");
        }
    }
    
    class C++Coder extends Coder {
        @Override
        public void coding() {
            System.out.println("笑死，java再牛逼底层不还的找我？");
        }
    }
}
```

通过提供一个Coder抽象类，定义出编程行为，但是不进行实现，开放给其他具体类型的程序员来进行实现，这样就可以根据业务进行灵活扩展了，具有较好的延续性。

### 里氏替换原则

里氏替换原则（Liskov Subsitution Principle）：是对子类型的特别定义，由芭芭拉`利斯科夫在1987年的一次会议上名为”数据的抽象与层次“的演说中提出的

> 所有引用基类的地方必须能透明的使用其子类的对象

简单理解：子类可以扩展父类的功能，尽量不重写父类原来就有的功能：

1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
2. 子类可以增加自己特有的方法。
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的的输入参数更宽松。
4. 当子类的方法可以实现父类的方法时，（重写/重载或实现抽象方法）。方法的后置条件是（即方法的输出/返回值）要比父类更严格或与父类一样。

例如：

```java
public abstract class Coder {

    public void coding() {
        System.out.println("我会打代码");
    }


    class JavaCoder extends Coder{

        /**
         * 子类除了会打代码之外，还会打游戏
         */
        public void game(){
            System.out.println("艾欧尼亚最强王者已上号");
        }
    }
}
```

可以看到JavaCoder继承了Coder，并没有重写父类的方法，而是新加了一个方法，进行额外扩展。符合里氏替换原则。

```java
public abstract class Coder {

    public void coding() {
        System.out.println("我会打代码");
    }


    class JavaCoder extends Coder{
        public void game(){
            System.out.println("艾欧尼亚最强王者已上号");
        }

        /**
         * 这里我们对父类的行为进行了重写，现在它不再具备父类原本的能力了
         */
        public void coding() {
            System.out.println("我寒窗苦读十六年，到最后还不如培训班三个月出来的程序员");
            System.out.println("想来想去，房子车子结婚彩礼，为什么这辈子要活的这么累呢？");
            System.out.println("难道来到这世间走这一遭就为了花一辈子时间买个房子吗？一个人不是也能活的轻松快乐吗？");
            System.out.println("摆烂了，啊对对对");  
          	//好了，emo结束，继续卷吧，人生因奋斗而美丽，这个世界虽然满目疮痍，但是还是有很多美好值得期待
        }
    }
}
```

这个JavaCoder继承了Coder，但是重写了父类中的Coder方法，这个子类已经不具备父类原本的行为，违背了里氏替换原则。

> 程序员不打代码，那就不是程序员了，不符合基本的定义。

对于这种情况，我们不需要再继承Coder，将父类的级别提升，将行为定义到People中

```java
// 抽象类和接口相似，抽象方法必须被继承者实现，非抽象方法，继承者可以不复写
public abstract class People {

    public abstract void coding();   //这个行为还是定义出来，但是不实现
    
    class Coder extends People{
        @Override
        public void coding() {
            System.out.println("我会打代码");
        }
    }


    class JavaCoder extends People{
        public void game(){
            System.out.println("艾欧尼亚最强王者已上号");
        }

        public void coding() {
            System.out.println("摆烂了，啊对对对");
        }
    }
}
```

**里氏替换也是实现开闭原则的重要方式之一，它告诉我们。继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来问解决问题。**

### 接口隔离原则

接口隔离原则（Interface Segregation Principle, ISP）实际上是对接口的细化。

> 客户端不应依赖那些它不需要的接口。

在定义接口的时候，一定要注意控制接口的粒度，比如下面的例子：

```java
interface Device {
    String getCpu();
    String getType();
    String getMemory();
}

//电脑就是一种电子设备，那么我们就实现此接口
class Computer implements Device {

    @Override
    public String getCpu() {
        return "i9-12900K";
    }

    @Override
    public String getType() {
        return "电脑";
    }

    @Override
    public String getMemory() {
        return "32G DDR5";
    }
}

//电风扇也算是一种电子设备
class Fan implements Device {

    @Override
    public String getCpu() {
        return null;   //就一个破风扇，还需要CPU？
    }

    @Override
    public String getType() {
        return "风扇";
    }

    @Override
    public String getMemory() {
        return null;   //风扇也不需要内存吧
    }
}
```

虽然我们定义了一个Device接口，但是由于此接口的粒度不够细，虽然比较契合电脑这种设备，但是不适合风扇这种设备，因为风扇压根就不需要CPU和内存，所以风扇完全不需要这些方法。这时我们就必须要对其进行更细粒度的划分：

```java
interface SmartDevice {   //智能设备才有getCpu和getMemory
    String getCpu();
    String getType();
    String getMemory();
}

interface NormalDevice {   //普通设备只有getType
    String getType();
}

//电脑就是一种电子设备，那么我们就继承此接口
class Computer implements SmartDevice {

    @Override
    public String getCpu() {
        return "i9-12900K";
    }

    @Override
    public String getType() {
        return "电脑";
    }

    @Override
    public String getMemory() {
        return "32G DDR5";
    }
}

//电风扇也算是一种电子设备
class Fan implements NormalDevice {
    @Override
    public String getType() {
        return "风扇";
    }
}
```

这样，我们就将接口进行了细粒度的划分，不同类型的电子设备就可以根据划分去实现不同的接口了。当然，也不能划分得太小，还是要根据实际情况来进行决定。

### 依赖倒转原则

依赖倒转原则（Dependence Inversion Principle）也是我们一直在使用的，最明显的就是我们的Spring框架了。

> - 高层模块不应依赖于底层模块，它们都应该依赖抽象。
> - 抽象不应依赖于细节，细节应该依赖于抽象。【提高稳定性】
> - 依赖倒转的中心思想是面向接口编程
> - 使用接口或者抽象类的目的是指定好规范，不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
> - 变量的声明类型尽量是抽象类或者接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化

**在spring框架中，我们一直使用接口去定义业务层的功能，然后在交由具体的实现类去实现。**

回顾一下使用spring之前的情况:

```java
public class Main {

    public static void main(String[] args) {
        UserController controller = new UserController();
      	//该怎么用就这么用
    }

    static class UserMapper {
        //CRUD...
    }

    static class UserService {
        UserMapper mapper = new UserMapper();
        //业务代码....
    }

    static class UserController {
        UserService service = new UserService();
        //控制层代码....
    }
}
```

但是突然有一天，公司业务需求变化，现在用户相关的业务操作需要使用新的实现：

```java
public class Main {

    public static void main(String[] args) {
        UserController controller = new UserController();
    }

    static class UserMapper {
        //CRUD...
    }

    static class UserServiceNew {   //由于UserServiceNew发生变化，会直接影响到其他高层模块
        UserMapper mapper = new UserMapper();
        //业务代码....
    }

    static class UserController {   //焯，干嘛改底层啊，我这又得重写了
        UserService service = new UserService();   //哦豁，原来的不能用了
        UserServiceNew serviceNew = new UserServiceNew();   //只能修改成新的了
        //业务代码....
    }
}
```

我们发现，我们的各个模块之间实际上是具有强关联的，一个模块是直接指定依赖于另一个模块，虽然这样结构清晰，但是底层模块的变动，会直接影响到其他依赖于它的高层模块，如果我们的项目变得很庞大，那么这样的修改将是一场灾难。



而有了Spring框架之后，我们的开发模式就发生了变化：

```java
public class Main {

public static void main(String[] args) {
    UserController controller = new UserController();
}

interface UserMapper {
    //接口中只做CRUD方法定义
}

static class UserMapperImpl implements UserMapper {
    //实现类完成CRUD具体实现
}

interface UserService {
    //业务代码定义....
}

static class UserServiceImpl implements UserService {
    @Resource   //现在由Spring来为我们选择一个指定的实现类，然后注入，而不是由我们在类中硬编码进行指定
    UserMapper mapper;
    
    //业务代码具体实现
}

static class UserController {
    @Resource
    UserService service;   //直接使用接口，就算你改实现，我也不需要再修改代码了

    //业务代码....
}
}
```
可以看到，通过使用接口，我们就可以将原有的强关联给弱化，我们只需要知道接口中定义了什么方法然后去使用即可，而具体的操作由接口的实现类来完成，并由Spring来为我们注入，而不是我们通过硬编码的方式去指定。

案例：person类里面有一个接受消息的功能

方式1 普通实现

```java
public class DependecyInversion {
    public static void main(String[] args) {
        Person person = new Person();
        person.recevier(new Email);
    }
}

// 电子邮件类
class Email {
    public String getInfo() {
        return "电子邮件信息：hello email";
    }
}

// 这样运行之后我们任然可以得到结果，person里的recevier方法直接依赖Email类
// 但是，如果像接受微信消息，就要在加一个类，去修改receiver的参数，添加微信方法
// 代码改动太多，
class person {
    public void receiver(Email email) {
        System.out.println(email.getInfo());
    }
}
```

方法2  升级实现

```java
package indi.exer.yuluo.Design.dependcyInversion;

/**
 * @Author: yuluo
 * @CreateTime: 2022-07-27  21:07
 * @Description: TODO
 */

public class DependenceInversion {
    public static void main(String[] args) {
        Person person = new Person();
        person.receiver(new Email());
        person.receiver(new WeiXin());
    }
}

// 接口
interface IRecevier {
    public String getInfo();
}

// 电子邮件类
class Email implements IRecevier{
    public String getInfo() {
        return "电子邮件信息：hello email";
    }
}

// 微信类
class WeiXin implements IRecevier {
    public String getInfo() {
        return "微信消息：hello weixin";
    }
}

// 方式2
class Person {
    public void receiver(IRecevier recevier) {
        System.out.println(recevier.getInfo());
    }
}

```

接口依赖倒转的方式

- 接口传递
- setter方法传递
- 构造方法传递

### 合成复用原则

合成复用原则（Composite Reuse Principle）的核心就是委派。

> 优先使用对象组合，而不是通过继承来达到复用的目的。

在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。实际上我们在考虑将某个类通过继承关系在子类得到父类已经实现的方法之外（比如A类实现了连接数据库的功能，恰巧B类中也需要，我们就可以通过继承来获得A已经写好的连接数据库的功能，这样就能直接复用A中已经写好的逻辑）我们应该应该优先地去考虑使用合成的方式来实现复用。

比如下面这个例子：

```java
class A {
    public void connectDatabase(){
        System.out.println("我是连接数据库操作！");
    }
}

class B extends A{    //直接通过继承的方式，得到A的数据库连接逻辑
    public void test(){
        System.out.println("我是B的方法，我也需要连接数据库！");
        connectDatabase();   //直接调用父类方法就行
    }
}
```

虽然这样看起来没啥毛病，但是还是存在我们之前说的那个问题，耦合度太高了。

可以看到通过继承的方式实现复用，我们是将类B直接指定继承自类A的，那么如果有一天，由于业务的更改，我们的数据库连接操作，不再由A来负责，而是由新来的C去负责，那么这个时候，我们就不得不将需要复用A中方法的子类全部进行修改，很显然这样是费时费力的。

并且还有一个问题就是，通过继承子类会得到一些父类中的实现细节，比如某些字段或是方法，这样直接暴露给子类，并不安全。

所以，当我们需要实现复用时，可以优先考虑以下操作：

```java
class A {
    public void connectDatabase(){
        System.out.println("我是连接数据库操作！");
    }
}

class B {   //不进行继承，而是在用的时候给我一个A，当然也可以抽象成一个接口，更加灵活
    public void test(A a){
        System.out.println("我是B的方法，我也需要连接数据库！");
        a.connectDatabase();   //在通过传入的对象A去执行
    }
}
```

或是：

```java
class A {
    public void connectDatabase(){
        System.out.println("我是连接数据库操作！");
    }
}

class B {
    
    A a;
    public B(A a){   //在构造时就指定好
        this.a = a;
    }
    
    public void test(){
        System.out.println("我是B的方法，我也需要连接数据库！");
        a.connectDatabase();   //也是通过对象A去执行
    }
}
```

通过对象之间的组合，我们就大大降低了类之间的耦合度，并且A的实现细节我们也不会直接得到了。

### 迪米特法则

迪米特法则（Law of Demeter）又称最少知识原则，是对程序内部数据交互的限制。

> 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。

简单来说就是，一个类/模块对其他的类/模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些。

其实说白了，还是降低耦合度，我们还是来看一个例子：

```java
public class Main {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("localhost", 8080);   //假设我们当前的程序需要进行网络通信
        Test test = new Test();
        test.test(socket);   //现在需要执行test方法来做一些事情
    }

    static class Test {
        /**
         * 比如test方法需要得到我们当前Socket连接的本地地址
         */
        public void test(Socket socket){
            System.out.println("IP地址："+socket.getLocalAddress());
        }
    }
}
```

可以看到，虽然上面这种写法没有问题，我们提供直接提供一个Socket对象，然后再由test方法来取出IP地址，但是这样显然违背了迪米特法则，实际上这里的`test`方法只需要一个IP地址即可，我们完全可以直接传入一个字符串，而不是整个Socket对象，我们需要保证与其他类的交互尽可能的少。

就像我们在餐厅吃完了饭，应该是我们自己扫码付款，而不是直接把手机交给老板来帮你操作付款。

要是某一天，Socket类中的这些方法发生修改了，那我们就得连带着去修改这些类，很麻烦。

所以，我们来改进改进：

```java
public class Main {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("localhost", 8080);
        Test test = new Test();
        test.test(socket.getLocalAddress().getHostAddress());  //在外面解析好就行了
    }

    static class Test {
        public void test(String str){   //一个字符串就能搞定，就没必要丢整个对象进来
            System.out.println("IP地址："+str);
        }
    }
}
```

再次降低了类和类之间的耦合度！

迪米特法则的核心是降低类之间的耦合度，而不要求完全没有依赖。尽可能的降低依赖关系。

## 创建型设计模式

和对象创建有关的设计模式

### 工厂模式

工厂方法的设计模式是用来替代new这种创建对象的方式的，为什么要替代原来的new创建对象的方式？

> 有如下场景：如果所有的对象都是用new的方式去创建，在我们的项目中大量的使用到这种对象，但是当对象的构造方法或者是类名发生变化，我们需要挨个去修改。根据迪米特法则。我们应该尽可能的减少与其他类进行交互，所以我们需要避免频繁出现的对象创建。可以将新建对象的过程封装到一个工厂类中，当我们需要对象时，直接调用工厂类中的方法来生成对象，这样，就算类出现了变动，只需要修改工厂中的代码即可，不需要大面积的进行秀修改！

同时，可能某些对象的常见不只是一个new就能处理的，可能还需要更多的步骤来构造方法需要的参数。所以我们来看看简单工厂模式如何创建对象：

水果抽象类：

```java
public abstract class Fruit {   //水果抽象类
    private final String name;
    
    public Fruit(String name){
        this.name = name;
    }

    @Override
    public String toString() {
        return name+"@"+hashCode();   //打印一下当前水果名称，还有对象的hashCode
    }
}
```

```java
public class Apple extends Fruit{   //苹果，继承自水果

    public Apple() {
        super("苹果");
    }
}
```

```java
public class Orange extends Fruit{  //橘子，也是继承自水果
    public Orange() {
        super("橘子");
    }
}
```

一般情况下，我们直接new就可以得到对象

```java
public class Main {
    public static void main(String[] args) {
        Apple apple = new Apple();
        System.out.println(apple);
    }
}
```

将创建对象的过程封装到工厂中：

> 在spring的应用中，可以通过反射的方式获取类名和类中的构造方法来达到创建对象的目的。

```java
public class FruitFactory {
    /**
     * 这里就直接来一个静态方法根据指定类型进行创建
     * @param type 水果类型
     * @return 对应的水果对象
     */
    public static Fruit getFruit(String type) {
        switch (type) {
            case "苹果":
                return new Apple();
           	case "橘子":
                return new Orange();
            default:
                return null;
        }
    }
}
```

现在使用工厂来创建水果对象

```java
public class Main {
    public static void main(String[] args) {
        Fruit fruit = FruitFactory.getFruit("橘子");   //直接问工厂要，而不是我们自己去创建
        System.out.println(fruit);
    }
}
```

不过这样还是有一些问题，我们前面提到了开闭原则，一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭，但是如果我们现在需要新增一种水果，比如桃子，那么这时我们就得去修改工厂提供的工厂方法了，但是这样是不太符合开闭原则的，因为工厂实际上是针对于调用方提供的，所以我们应该尽可能对修改关闭。

所以，我们就利用对扩展开放，对修改关闭的性质，将`简单工厂模式【又称为静态工厂模式】`改进为`工厂方法模式`，那现在既然不让改，那么我们就看看如何去使用扩展的形式：

```java
//将水果工厂抽象为抽象类，添加泛型T由子类指定水果类型
public abstract class FruitFactory<T extends Fruit> { 
    
    //不同的水果工厂，通过此方法生产不同的水果
    public abstract T getFruit();  
}
```

```java
//苹果工厂，直接返回Apple，一步到位
public class AppleFactory extends FruitFactory<Apple> {  
    @Override
    public Apple getFruit() {
        return new Apple();
    }
}
```

这样，我们就可以使用不同类型的工厂来生产不同类型的水果了，并且如果新增了水果类型，直接创建一个新的工厂类就行，不需要修改之前已经编写好的内容。

```java
public class Main {
    public static void main(String[] args) {
        test(new AppleFactory()::getFruit);   //比如我们现在要吃一个苹果，那么就直接通过苹果工厂来获取苹果
    }

    //此方法模拟吃掉一个水果
    private static void test(Supplier<Fruit> supplier){
        System.out.println(supplier.get()+" 被吃掉了，真好吃。");
    }
}
```

这样，我们就实现了简单的工厂方法设计模式，通过工厂来屏蔽对象的创建细节，使用者只需要关心如何去使用对象即可。

### 抽象工厂模式

前面我们介绍了工厂方法模式，通过定义顶层抽象工厂类，通过继承的方式，针对于每一个产品都提供一个工厂类用于创建。

不过这种模式只适用于简单对象，当我们需要生产许多个产品族的时候，这种模式就有点乏力了，比如：

![img](.\设计模式.assets\imagesurl=https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2Fe6c9d24egy1h2g3rpau36j218u0e0jt8.jpg&sign=244c5213f4d91dfa0053b8d58ea7b64939a7d046e8639bc5abbeb470f2304e3a)

实际上这些产品都是成族出现的，比如小米的产品线上有小米12，小米平板等，华为的产品线上也有华为手机、华为平板，但是如果按照我们之前工厂方法模式来进行设计，那就需要单独设计9个工厂来生产上面这些产品，显然这样就比较浪费时间的。

但是现在有什么方法能够更好地处理这种情况呢？我们就可以使用抽象工厂模式，我们可以将多个产品，都放在一个工厂中进行生成，按不同的产品族进行划分，比如小米，那么我就可以安排一个小米工厂，而这个工厂里面就可以生产整条产品线上的内容，包括小米手机、小米平板、小米路由等。

所以，我们只需要建立一个抽象工厂即可

```java
public class Router {
}
```

```java
public class Table {
}
```

```java
public class Phone {
}
```

```java
public abstract class AbstractFactory {
    public abstract Phone getPhone();
    public abstract Table getTable();
    public abstract Router getRouter();
}
```

一个工厂可以生产同一个产品族的所有产品，这样按族进行分类，显然比之前的工厂方法模式更好。

不过，缺点还是有的，如果产品族新增了产品，那么我就不得不去为每一个产品族的工厂都去添加新产品的生产方法，违背了开闭原则。



抽象工厂方法示例：类图

![image-20220802111207137](.\设计模式.assets\image-20220802111207137.png)

工厂方法在jdk的Calendr【日历】中应用到。

```java
 Calender calender = Calender.getInstance();
```

### 单例模式

单例模式：顾名思义就是只有一个实例对象，在整个程序中，同一个类始终只会有一个对象来进行操作。比如数据库连接类，session工厂等重量级对象，实际上我们只需要创建一个对象或是直接使用静态方式就可以了，没必要创建多个对象。

饿汉式单例【静态常量】

```java
public class Singleton {
    
    // 用于引用全局唯一的单例对象，在一开始类加载的时候就创建好
    private final static Singleton INSTANCE = new Singleton();   
    
    private Singleton() {}   //不允许随便new，需要对象直接找getInstance
    
    public static Singleton getInstance(){   //获取全局唯一的单例对象
        return INSTANCE;
    }
 
	// 当我们需要时，只能通过getInstance方法来获取唯一的对象：  
	public static void main(String[] args) {
       Singleton singleton = Singleton.getInstance(); 
	}
}
```

静态常量的缺点是：

1. 缺点：没有懒加载的效果，如果从未使用过这个实例，会造成内存浪费问题
2. 优点：写法简单，避免了线程同步问题

饿汉式单例【静态代码块】

```java
public class Singleton {
    
    // 引用全局唯一的单例对象
    private final static Singleton INSTANCE;   
    
    //私有化构造方法，不允许随便new，需要对象直接找getInstance
    private Singleton() {}   
    
    static {
        // 在类加载时完成对静态变量的赋值
		INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance(){   //获取全局唯一的单例对象
        return INSTANCE;
    }
}
```

另一种写法——`懒汉式`【存在线程安全问题】：

```java
public class Singleton {
    private static Singleton INSTANCE;   //在一开始先不进行对象创建

    private Singleton() {}   //构造器私有化

    public static Singleton getInstance(){   //将对象的创建延后到需要时再进行
        if(INSTANCE == null) {    //如果实例为空，那么就进行创建，不为空说明已经创建过了，那么就直接返回
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }
}
```

可以看到，懒汉式就真的是条懒狗，你不去用它，它是不会给你提前准备单例对象的（延迟加载，懒加载），当我们需要获取对象时，才会进行检查并创建。虽然饿汉式和懒汉式写法不同，但是最后都是成功实现了单例模式。

不过，这里需要特别提醒一下，由于懒汉式是在方法中进行的初始化，在多线程环境下，可能会出现问题（建议学完JUC篇视频教程再来观看）大家可以试想一下，如果这个时候有多个线程同时调用了`getInstance()`方法，那么会出现什么问题呢？

![img]((.\设计模式.assets\imagesurl=https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2Fe6c9d24egy1h2h90c124gj21ae0bedhw.jpg&sign=91cad0b8bacae262091a02c2c11db3f57b67ed05b22dc5967fd61e5c53ef9183)

可以看到，在多线程环境下，如果三条线程同时调用`getInstance()`方法，会同时进行`INSTANCE == null`的判断，那么此时由于确实还没有进行任何实例化，所以导致三条线程全部判断为`true`（而饿汉式由于在类加载时就创建完成，不会存在这样的问题）此时问题就来了，我们既然要使用单例模式，那么肯定是只希望对象只被初始化一次的，但是现在由于多线程的机制，导致对象被多次创建。

所以，为了避免线程安全问题，针对于懒汉式单例，我们还得进行一些改进：

```java
public static synchronized Singleton getInstance(){   //方法必须添加synchronized关键字加锁
    if(INSTANCE == null) {
        INSTANCE = new Singleton();
    }
    return INSTANCE;
}
```

既然多个线程要调用，那么我们就直接加一把锁，在方法上添加synchronized关键字即可，这样同一时间只能有一个线程进入了。虽然这样简单粗暴，但是在高并发的情况下，效率肯定是比较低的，我们来看看如何进行优化：

```java
public static Singleton getInstance(){
    if(INSTANCE == null) {
        synchronized (Singleton.class) {    //实际上只需要对赋值这一步进行加锁即可
            INSTANCE = new Singleton();   
        }
    }
    return INSTANCE;
}
```

不过这样还不完美，因为这样还是有可能多个线程同时判断为`null`而进入等锁的状态，产生多个实例。所以，我们还得加一层内层判断：【双重检查】

```java
private Singleton() {}

// volatile轻量级的synchronized
private static volatile Singleton INSTANCE;

public static Singleton getInstance(){
    if(INSTANCE == null) {
        synchronized (Singleton.class) {
            if(INSTANCE == null) {
                INSTANCE = new Singleton();  //内层还要进行一次检查，双重检查锁定，能够保证此时只有一个线程
            }
        }
    }
    return INSTANCE;
}

// Double-check概念时多线程开发中经常用到的，这种写法效率较高，推荐在开发中使用
```

那么，有没有一种更好的，不用加锁的方式也能实现延迟加载的写法呢？我们可以使用静态内部类：

```java
// 静态内部类的特点，外部类装载的时候，内部类不会被立即装载
// 在调用getInstance方法的时候，内部类才会被装载    
// jvm装载类的时候，别的线程是无法进入的，是线程安全的

public class Singleton {
    
    private Singleton() {}

    //由静态内部类持有单例对象，但是根据类加载特性，我们仅使用Singleton类时，不会对静态内部类进行初始化，实现懒加载
    private static class Holder {   
        private final static Singleton INSTANCE = new Singleton();
    }

    //只有真正使用内部类时，才会进行类初始化
    public static Singleton getInstance(){   
        //直接获取内部类中的
        return Holder.INSTANCE;   
    }
}
```

这种方式显然是最完美的懒汉式解决方案，没有进行任何的加锁操作，也能保证线程安全，不过要实现这种写法，跟语言本身也有一定的关联，并不是所有的语言都支持这种写法。

枚举方式

使用枚举也可以实现单例模式，不仅能避免线程同步问题，而且还能防止反序列化创建新的对象

```java
enum Singleton {
    INSTANCE;
    public static Singleton getInstance() {
        private static final signleton = new Singleton();
    }
}
```

**在jdk中的Runtime中使用了单例模式的饿汉式写法**

### 原型模式        [prototype]

原型模式实际上与对象的拷贝息息相关，原型模式使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。也就是说，原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。

开始之前，我们先介绍一下对象的深拷贝和浅拷贝，首先我们来看浅拷贝：

-  **浅拷贝：**对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，hascode相同，拷贝个基莫。 

  ```java
  public static void main(String[] args) {
      int a = 10;
      int b = a;  //基本类型浅拷贝
      System.out.println(a == b);
  
      Object o = new Object();
      Object k = o;    //引用类型浅拷贝，拷贝的仅仅是对上面对象的引用
      System.out.println(o == k);
  }
  ```

  

-  **深拷贝：**无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。 

在Java中，我们就可以使用Cloneable接口提供的拷贝机制，来实现原型模式：

```java
public class Student implements Cloneable{   //注意需要实现Cloneable接口
    @Override
    public Object clone() throws CloneNotSupportedException {   //提升clone方法的访问权限
        return super.clone();
    }
}
```

但是，通过`clone()`方法克隆的对象并不是原来的对象，我们来看看如果对象内部有属性会不会一起进行克隆。同样，当对象内部有内层对象的时候，依然只是对象引用的复制。

```java
public class Student implements Cloneable{
    
    String name;

    public Student(String name){
        this.name = name;
    }
    
    public String getName() {
        return name;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```java
public static void main(String[] args) throws CloneNotSupportedException {
    Student student0 = new Student("小明");
    Student student1 = (Student) student0.clone();
    System.out.println(student0.getName() == student1.getName());
}
```

所以java的clone方法只会进行浅拷贝。

对象深拷贝的实现方式：

- 通过重写clone方法进行拷贝

```java
@Override
public Object clone() throws CloneNotSupportedException {   //这里我们改进一下，针对成员变量也进行拷贝
    Student student = (Student) super.clone();
    // 对引用类型的属性进行单独拷贝
    student.name = new String(name);
    return student;   //成员拷贝完成后，再返回
}
```

- 通过对象序列化实现深拷贝 （推荐使用）

```java
public Object deelClone() {
    
    // 创建流对象
    ByteArrayOutputStream bos = null;
    ObjectOutputStream oos = null;
    
    ByteArrayInoutStream bis = null;
    ObjectInputStream ois = null;
    
    try {
        // 序列化
        bos = new ByteArrayOutputStream();
        oos = new ObjectOutputStream();
        // 将当前这个对象以对象流的方式输出  
        oos.writeObejct(this);
        
        // 反序列化
        bis = nwq ByteArrayInoutStream(bos.toByteArray());
        ois = new ObjectInputStream(bis);
        DeepProtoType copyObj = (DeepPrototype)ois.readObject();
        
        retrun copyObj
    } catch (Exception e) {
        e,printStackTrace();
        return null;
    } finally {
        // 关闭
        try {
           bos.close();
           oos.close();
           bis.close();
           ois.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
}
```

### 建造者模式

建造者模式也是一种非常常见的设计模式，经常看到很对框架提供了形如XXXBuilder的类型，我们一般通过使用这些类来创建我们需要的对象。

> 将产品和产品建造过程解耦 => 建造者模式
>
> 建造者模式的四个角色：
>
> - Product【产品角色】：一个具体的产品对象
> - Buildert【抽象建造者】：创建一个Product对象的各个部件指定的接口/抽象类
> - concreteBuilder 【具体建造者】：实现接口，构建和装配各个部件
> - Director【指挥者】：构建一个使用Builder接口的对象，主要用于创建一个复杂的对象。有两个主要作用：
>   1. 隔离客户与对象的生产过程
>   2. 负责控制产品对象的生产过程
>
> ![image-20220803111511755](.\设计模式.assets\image-20220803111511755.png)

比如：JDK中的StringBuilder类

```java
public static void main(String[] args) {
    
    //创建一个StringBuilder来逐步构建一个字符串
    StringBuilder builder = new StringBuilder();   
    builder.append(666);   //拼接一个数字
    builder.append("老铁");   //拼接一个字符串
   	builder.insert(2, '?');  //在第三个位置插入一个字符
    System.out.println(builder.toString());   //差不多成形了，最后转换为字符串
}
```

实际上我们是通过建造者来不断配置参数或是内容，当我们配置完所有内容后，最后再进行对象的构建。

相比直接去new一个新的对象，建造者模式的重心更加关注在如何完成每一步的配置，同时如果一个类的构造方法参数过多，我们通过建造者模式来创建这个对象，会更加优雅。

比如我们现在有一个学生类：【在创建实体对象时的用法】

```java
public class Student {
    int id;
    int age;
    int grade;
    String name;
    String college;
    String profession;
    List<String> awards;

    public Student(int id, int age, int grade, String name, String college, String profession, List<String> awards) {
        this.id = id;
        this.age = age;
        this.grade = grade;
        this.name = name;
        this.college = college;
        this.profession = profession;
        this.awards = awards;
    }
}
```

创建对象时：

```java
public static void main(String[] args) {
    Student student = new Student(1, 18, 3, "小明", "计算机学院", "计算机科学与技术", Arrays.asList("ICPC-ACM 区域赛 金牌", "LPL 2022春季赛 冠军"));
}
```

在填入参数的时候会非常麻烦，所以我们可以通过建造者设计模式去完成参数的设置和对象的创建：

```java
public class Student {
		...

    //一律使用建造者来创建，不对外直接开放
    private Student(int id, int age, int grade, String name, String college, String profession, List<String> awards) {
        ...
    }

    public static StudentBuilder builder(){   //通过builder方法直接获取建造者
        return new StudentBuilder();
    }

    public static class StudentBuilder{   //这里就直接创建一个内部类
        //Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义
        int id;
        int age;
        int grade;
        String name;
        String college;
        String profession;
        List<String> awards;

        public StudentBuilder id(int id){    //直接调用建造者对应的方法，为对应的属性赋值
            this.id = id;
            return this;   //为了支持链式调用，这里直接返回建造者本身，下同
        }

        public StudentBuilder age(int age){
            this.age = age;
            return this;
        }
      
      	...

        public StudentBuilder awards(String... awards){
            this.awards = Arrays.asList(awards);
            return this;
        }
        
        public Student build(){    //最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象
            return new Student(id, age, grade, name, college, profession, awards);
        }
    }
}
```

创建对象：

```java
public static void main(String[] args) {
    Student student = Student.builder()   //获取建造者
            .id(1)    //逐步配置各个参数
            .age(18)
            .grade(3)
            .name("小明")
            .awards("ICPC-ACM 区域赛 金牌", "LPL 2022春季赛 冠军")
            .build();   //最后直接建造我们想要的对象
}
```

比之前的方式优雅许多，可读性和代码量都相应减少！

如下的使用方式：

```java
package indi.exer.yuluo.Design.BuilderDesign;

/**
 * @Author: yuluo
 * @CreateTime: 2022-07-25  17:33
 * @Description: TODO
 */

public class Student {

    private Integer id;
    private String name;
    private Integer age;
    private String date;

    /**
     * 全部使用建造者创建，不对外开放
     * @param id
     * @param name
     * @param age
     * @param date
     */
    private Student(Integer id, String name, Integer age, String date) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.date = date;
    }


    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", date='" + date + '\'' +
                '}';
    }

    /**
     * 内部类
     */
    public static class StudentBuilder {
        // 必须要填写的属性不赋值
        private Integer id;
        private String name;

        // 次要的属性可以赋值，在填入参数时选择传入即可, 不传入就是默认值
        private Integer age = 20;
        private String date = "2020.01.01";

        /**
         * 创建student对象时必须要传入id和name属性值
         * @param id
         * @param name
         */
        public StudentBuilder(Integer id, String name) {
            this.id = id;
            this.name = name;
        }

        public StudentBuilder id(Integer id) {
            this.id = id;
            // 为了支持链式调用，这里返回建造者本身
            return this;
        }

        public StudentBuilder name(String name) {
            this.name = name;
            return this;
        }

        public StudentBuilder age(Integer age) {
            this.age = age;
            return this;
        }

        public StudentBuilder date(String date) {
            this.date = date;
            return this;
        }

        // 最后使用建造者调用build方法即可完成对象的创建
        public Student build() {
            return new Student(id, name, age, date);
        }

    }

    // 通过builder方法获取建造者
    public static StudentBuilder builder(Integer id, String name) {
        return new StudentBuilder(id, name);
    }
}
```

可以通过控制StudentBuilder类的构造方法去控制student对象必要的参数和默认值：

```java
package indi.exer.yuluo.Design.BuilderDesign;

/**
 * @Author: yuluo
 * @CreateTime: 2022-07-25  17:33
 * @Description: TODO
 */

public class Text {

    public static void main(String[] args) {
        // Student yuluo = Student.builder()
        //         .id(001)
        //         .name("yuluo")
        //         .build();
        //
        // System.out.println(yuluo);
        //
        // Student huakai = Student.builder()
        //         .id(002)
        //         .name("huakai")
        //         .age(21)
        //         .build();
        // System.out.println(huakai);
        //
        // Student zhangsan = Student.builder()
        //         .name("zhangsan")
        //         .age(21)
        //         .build();
        // System.out.println(zhangsan);

        Student lisi = Student.builder(003, "lisi").build();
        System.out.println(lisi);

    }

}
```

## 结构性设计模式

结构型设计模式关注如何将现有的类或者对象组织在一起形成更加强大的结构，并且根据合成复用原则，该如何尽可能的使用关联关系来代替继承关系是结构性设计模式的重点内容！

### 适配器模式

在生活中，我们经常遇到这样的一个问题：笔记本太轻薄了，以至于没有RJ45网口和USB A口（比如Macbook为了轻薄甚至全是type-c形式的雷电口）但是现在我们因为工作需要，又得使用这些接口来连接线缆，这时我们想到的第一个解决方案，就是去买一个转接口（扩展坞），扩展坞可以将type-c口转换为其他类型的接口供我们使用，实际上这就是一种适配模式。

![img](.\设计模式.assets\imagesurl=https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2Fe6c9d24egy1h2hnb1v5ytj21e20be401.jpg&sign=4b8856fe46aa5aea7281683be3627b83a6375b4e070dbfb029df95d0a8c1ba40)

由于我们的电脑没有这些接口，但是提供了type-c类型的接口，虽然接口类型不一样，但是同样可以做其他接口能做的事情，比如USB文件传输、有线网络连接等，所以，这个时候，我们只需要添加一个中间人来帮我们转换一下接口形态即可。包括我们常用的充电头，为什么叫电源适配器呢？我们知道传统的供电是220V交流电，但是我们的手机可能只需要5V的电压进行充电，虽然现在有电，但是不能直接充，我们也不可能让电力公司专门为我们提供一个5V的直流电使用。这时电源适配器就开始发挥作用了，比如苹果的祖传5V1A充电头，实际上就是将220V交流电转换为5V的直流电进行传输，这样就相当于在220V交流电和我们的手机之前，做了一个适配器的角色。

比如下面场景：

```java
public class TestSupplier {   //手机供应商

    public String doSupply(){
        return "iPhone 14 Pro";
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        TestSupplier supplier = new TestSupplier();
      	test( ? );   //我们没有Target类型的手机供应商，只有其他的，那这里该填个啥
    }

    public static void test(Target target){   //现在我们需要调用test方法，但是test方法需要Target类型的手机供应商
        System.out.println("成功得到："+target.supply());
    }
}
```

现在我们可以使用适配器模式，适配器模式分为类适配器和对象适配器、接口适配器，我们首先来看看如何使用类适配器解决这种问题，我们直接创建一个适配器类：

```java
public class TestAdapter extends TestSupplier implements Target {  
  //让我们的适配器继承TestSupplier并且实现Target接口
    @Override
    public String supply() {   //接着实现supply方法，直接使用TestSupplier提供的实现
        return super.doSupply();
    }
}
```

这样，我们就得到了一个Target类型的实现类，并且同时采用的是TestSupplier提供的实现。

```java
public static void main(String[] args) {
    TestAdapter adapter = new TestAdapter();
    test(adapter);
}

public static void test(Target target){
    System.out.println("成功得到："+target.supply());
}
```

不过，这种实现方式需要占用一个继承位，如果此时Target不是接口而是抽像类的话，由于Java不支持多继承，那么就无法实现了。同时根据合成复用原则，我们应该更多的通过合成的方式去实现功能，所以我们来看看第二种，也是用的比较多的一种模式，对象适配器：

```java
public class TestAdapter implements Target{   //现在不再继承TestSupplier，仅实现Target

    TestSupplier supplier;
    
    public TestAdapter(TestSupplier supplier){
        this.supplier = supplier;
    }
    
    @Override
    public String supply() {
        return supplier.doSupply();
    }
}
```

总结：

Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作

分为类适配器，接口适配器和对象适配器

### 桥接模式 【Bridge】

介绍：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变，

> 桥接模式基于类的最小设计原则，通过封装，继承和聚合等行为让不同的类承担不同的职责，
>
> 主要特点是把抽象与行为实现分离开，从而保持各部分的独立性以及应对他们的功能扩展

手机样式问题：

![image-20220805103703668](.\设计模式.assets\image-20220805103703668.png)

代码实现：

```java
// 手机品牌功能
public interface Brand {

    void open();

    void close();

    void call();

}
```

```java
// 手机品牌的具体实现
public class XiaomiPhone implements Brand{
    @Override
    public void open() {
        System.out.println("小米手机开机了");
    }

    @Override
    public void close() {
        System.out.println("小米手机关机了");
    }

    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }
}

public class VivoPhone implements Brand {
    @Override
    public void open() {
        System.out.println("vivo手机开机了");
    }

    @Override
    public void close() {
        System.out.println("vivo手机关机了");
    }

    @Override
    public void call() {
        System.out.println("vivo手机打电话");
    }
}
```

手机抽象类

```java
public abstract class Phone {

    // 组合品牌
    private Brand brand;


    public Phone(Brand brand) {
        super();
        this.brand = brand;
    }

    // 根据传进来的品牌去调用相应的方法
    protected void open() {
        this.brand.open();
    }

    protected void close() {
        this.brand.close();
    }

    protected void call() {
        this.brand.call();
    }
}
```

手机的具体样式

```java
public class FoldedPhone extends Phone{

    public FoldedPhone(Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println("折叠样式手机");
    }

    public void close() {
        super.close();
        System.out.println("折叠样式手机");
    }

    public void call() {
        super.call();
        System.out.println("折叠样式手机");
    }
}

public class UpRightPhone extends Phone{

    public UpRightPhone (Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println("直立样式手机");
    }

    public void close() {
        super.close();
        System.out.println("直立样式手机");
    }

    public void call() {
        super.call();
        System.out.println("直立样式手机");
    }

}
```

客户端调用：

```java
package indi.exer.yuluo.Design.bridge;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-05  10:21
 * @Description: TODO
 */

public class Client {

    public static void main(String[] args) {
        // 获取折叠式手机 样式+品牌
        Phone foldedXiaomiPhone = new FoldedPhone(new XiaomiPhone());
        foldedXiaomiPhone.open();
        foldedXiaomiPhone.call();
        foldedXiaomiPhone.close();

        System.out.println("================");

        Phone phone = new UpRightPhone(new XiaomiPhone());
        phone.open();
        phone.call();
        phone.close();

        System.out.println("=====================");

        Phone vivoPhone = new FoldedPhone(new VivoPhone());
        vivoPhone.call();
        vivoPhone.close();
        vivoPhone.open();
    }

}
```

JDBC的Driver接口：里面有Mysql的Driver，Oracle的Driver……，Driver就可以当作一个桥梁

![image-20220805105103591](.\设计模式.assets\image-20220805105103591.png)

总结：

桥接模式实现了抽象和实现部分的分离，极大的提高了系统的灵活性，使得抽象部分独立开来，有助于系统进行分层设计，产生更好的结构化系统。

对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他的部分由业务类来完成。

桥接模式可以替代多层继承方案，减少子类个数。

桥接模式的引入增加了系统的理解和设计维度，要求开发者针对抽象进行设计和编程

桥接模式要求正确识别处系统中两个独立变化的维度，因此使用具有一定范围的局限性，需要有相应的使用场景：

![image-20220805105311346](.\设计模式.assets\image-20220805105311346.png)

### 组合模式

例：

> 展示学校的学院和系之间的关系

- 传统方案就是将学院看成学习的子类，再将系看成学院的子类，这样实际上是站在组织大小的层次上区分的
- 我的要求是：在一个页面中展示出学校的院系组成，这种方案不能很好的实现管理操作。
- 解决方案：将学校、院、系看成一个组织解耦，之间没有继承关系。而是一个树型关系，可以更好的实现管理操作  ==> 组合模式

![image-20220807080045074](.\设计模式.assets\image-20220807080045074.png)

代码实现：

组织组合：

```java
package indi.exer.yuluo.Design.composite;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-07  08:01
 * @Description: TODO
 */

public abstract class OrganizationComponent {

    // 名字
    private String name;

    // 描述
    private String des;

    protected void add(OrganizationComponent organizationComponent) {
        // 默认实现
        throw new UnsupportedOperationException();
    }

    protected void remove(OrganizationComponent organizationComponent) {
        // 默认实现
        throw new UnsupportedOperationException();
    }

    public OrganizationComponent(String name, String des) {
        super();
        this.name = name;
        this.des = des;
    }

    // 打印方法 抽象的
    protected abstract void print();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }
}
```

```java
package indi.exer.yuluo.Design.composite;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-07  08:05
 * @Description: TODO
 */

public class University extends OrganizationComponent {

    // list中存放的是学院 college
    List<OrganizationComponent> organizationComponents = new ArrayList<>();

    public University(String name, String des) {
        super(name, des);
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }

    @Override
    protected void print() {
        // 输出University中包含的学院
        System.out.println("---------------" + getName() + "-----------------");
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }
}
```

```java
package indi.exer.yuluo.Design.composite;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-07  08:05
 * @Description: TODO
 */

public class College extends OrganizationComponent {


    // list中存放的是department
    List<OrganizationComponent> organizationComponents = new ArrayList<>();

    public College(String name, String des) {
        super(name, des);
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }

    @Override
    protected void print() {
        // 输出University中包含的院系
        System.out.println("---------------" + getName() + "-----------------");
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }
}
```

```java
package indi.exer.yuluo.Design.composite;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-07  08:06
 * @Description: TODO
 */

public class Department extends OrganizationComponent{

    // 不用重写add和remove方法了，是叶子节点

    public Department(String name, String des) {
        super(name, des);
    }

    @Override
    protected void print() {
        System.out.println(getName());
    }
}
```

```java
package indi.exer.yuluo.Design.composite;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-07  08:15
 * @Description: TODO
 */

public class Client {

    public static void main(String[] args) {
        // 从大到小创建对象

        // 创建学校
        OrganizationComponent university = new University("清华大学", "中国顶级大学");

        // 创建学院
        OrganizationComponent computerCollege = new College("计算机学院", "计算机");
        OrganizationComponent infoEngineerCollege = new College("信息工程学院", "信息工程学院");

        // 创建学院下面的系
        computerCollege.add(new Department("计算机科学与技术", "计科"));
        computerCollege.add(new Department("网络技术", "网络"));
        computerCollege.add(new Department("物联网技术", "物联网"));

        infoEngineerCollege.add(new Department("信息工程不好学", "不好学"));
        infoEngineerCollege.add(new Department("通信工程不好学", "好学"));

        // 将学院加到学校中
        university.add(computerCollege);
        university.add(infoEngineerCollege);

        // 输出
        university.print();
    }

}
```

将学校和院，系的公共属性和方法抽取出来，University和college，department分别继承，三者之间是聚合关系。很方便的实现了学院信息展示的功能。

**jdk中的HashMap使用了组合模式**

组合模式的注意事项和细节：

> 简化客户端操作，客户端只需要面对相同的对象，不需要考虑整体部分或者叶子节点
>
> 具有较强的扩展性，当更改组合对象时，只需要调整内部的层次关系，客户端不需要改动
>
> 方便创建复杂的层次结构，客户端不需要理具体的组成细节。
>
> 当组织机构具有树形结构时，非常适合使用组合模式
>
> 要求具有较高的抽象性，如果节点和叶子有很多差异性，比如方法和属性不同。不适用组合模式

### 装饰模式

简介：**动态的将新功能附加到对象上**，在对象功能扩展方面，比继承更有弹性，装饰者模式也体现了开闭原则（OCP）

例：

> 咖啡种类/单品咖啡:Espresso(意大利浓咖啡)、shortBlasck、LognBlack(美式咖啡)、Decaf(无因咖啡)
>
> 调料：Milk、soy(豆浆)、Chosolate
>
> 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
>
> 使用面向对象的方式来计算不同种类咖啡的费用：客户可以点单品咖啡，也可以单品咖啡+调料组合

按照平常设计，咖啡和调料之间的组合会有多种，会造成类爆炸的问题。项目难以维护。

可以考虑使用装饰者设计模式：

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  09:48
 * @Description: 咖啡
 */

public abstract class Drink {

    // 描述
    public String des;

    // 价格
    private float price = 0.0f;

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    // 计算价格的抽象方法
    // 交给子类去实现
    public abstract float cost();
}
```

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  09:51
 * @Description: TODO
 */

public class Coffee extends Drink{

    @Override
    public float cost() {
        return super.getPrice();
    }
}
```

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  09:52
 * @Description: TODO
 */

public class Espresso extends Coffee{

    public Espresso() {
        setDes("意大利咖啡");
        setPrice(6.0f);
    }
}
```

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  09:53
 * @Description: TODO
 */

public class LongBlack extends Coffee{

    public LongBlack() {
        setDes("美式咖啡");
        setPrice(7.0f);
    }
}
```

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  09:54
 * @Description: TODO
 */

public class ShortBlack extends Coffee{

    public ShortBlack() {
        setDes("shortBlack");
        setPrice(8.0f);
    }
}
```

装饰者：

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  09:54
 * @Description: TODO
 */

public class Decorator extends Drink {

    // 体现出组合关系
    public Decorator(Drink obj) {
        this.obj = obj;
    }

    private Drink obj;

    @Override
    public float cost() {
        // 先拿到自己的价格，
        return super.getPrice() + obj.cost();
    }

    @Override
    public String getDes() {
        // obj.getDes被装饰者的描述信息
        return des + " " + getPrice() + " && " + obj.getDes();
    }
}
```

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  09:58
 * @Description:
 */

// 具体的Decorator，这里就是调味品
public class Chocolate extends Decorator{

    public Chocolate(Drink obj) {
        super(obj);
        setDes("调味品是巧克力");
        // 当前调味品的价格
        setPrice(3.5f);
    }
}
```

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  09:59
 * @Description: TODO
 */

public class Milk extends Decorator{

    public Milk(Drink obj) {
        super(obj);
        setDes("这是牛奶调味品");
        setPrice(2.0f);
    }
}
```

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  10:00
 * @Description: TODO
 */

public class Soy extends Decorator {

    public Soy(Drink obj) {
        super(obj);
        setDes("这是豆浆调味品");
        setPrice(2.5f);
    }
}
```

```java
package indi.exer.yuluo.Design.decorator;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-06  10:21
 * @Description: TODO
 */

// 咖啡店
public class CoffeeStore {

    // 装饰者模式下的咖啡订单
    public static void main(String[] args) {
        // 1、一份LongBlack
        Drink order = new LongBlack();
        System.out.println("费用1：" + order.getPrice());
        System.out.println("描述信息：" + order.getDes());

        // 2、加入一份牛奶
        order = new Milk(order);
        System.out.println("加入一份牛奶之后的费用：" + order.cost());
        System.out.println("加入一份牛奶之后的描述信息：" + order.getDes());

        // 3、加入一份巧克力
        order = new Chocolate(order);
        System.out.println("加入一份巧克力之后的费用：" + order.cost());
        System.out.println("加入一份巧克力之后的描述信息：" + order.getDes());
    }
}
```

在jdk中的应用：FilterInputStream

![image-20220806103449319](.\设计模式.assets\image-20220806103449319.png)

### 代理模式

> 代理模式：为一个对象提供一个替身，以控制这个对象的访问，即通过代理对象访问目标对象，这样的做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。
>
> 被代理的对象可以是远程对象，创建开销比较大的对象或者需要安全控制的对象
>
> 代理模式有不同的形式：主要有三种：静态代理、动态代理[JDK代理，接口代理]、cglib代理[在内存中动态的创建对象，不需要实现接口]。

#### 静态代理

静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类

![image-20220809084758102](.\设计模式.assets\image-20220809084758102.png)

#### 动态代理

1. 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理

2. 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象

3. 动态代理也叫做：JDK代理，接口代理

4. JDK中生成代理对象使用的API

   1. 代理类所在的包：`javs.lang.reflect.Proxy`

   2. JDK实现代理只需要使用 `newProxyInstance`方法，但是该方法需要接受三个参数

      ```java
      static Object newProxyInstance(ClassLoader, Class<?>[] interaces, InvocationHandler h)
      ```

![image-20220809090423172](.\设计模式.assets\image-20220809090423172.png)

接口类型：

```java
package indi.exer.yuluo.Design.proxy.dynamicProxy;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-09  09:06
 * @Description: TODO
 */

public interface ITeacherDao {

    void teach();

}
```

实现类：

```java
package indi.exer.yuluo.Design.proxy.dynamicProxy;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-09  09:07
 * @Description: TODO
 */

public class TeacherDao implements ITeacherDao{
    @Override
    public void teach() {
        System.out.println("老师授课……");
    }
}
```

代理工厂；

```java
package indi.exer.yuluo.Design.proxy.dynamicProxy;

import com.alibaba.druid.sql.dialect.ads.visitor.AdsOutputVisitor;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Objects;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-09  09:06
 * @Description: TODO
 */

public class ProxyFactory {

    private Object target;

    // 通过代理对象注入需要维护目标对象
    public ProxyFactory(Object target) {
        this.target = target;
    }

    // 给目标对象生成代理对象
    public Object getProsyInstances() {

        /**
         *     public static Object newProxyInstance(ClassLoader loader,
         *                                           Class<?>[] interfaces,
         *                                           InvocationHandler h)
         *         throws IllegalArgumentException
         * 方法说明
         *  1. ClassLoader loader : 指定当前目标对象使用的类加载器，获取加载器的方法固定
         *  2. Class<?> interfaces: 目标对象实现的接口类型，使用泛型确认类型
         *  3. InvocationHandler h：事情处理，执行目标对象的方法时，触发事情处理器方法，
         *                          把当前执行的目标对象方法作为一个参数传入
         */
        Object o = Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                (proxy, method, args) -> {
                    System.out.println("jdk代理开始……");

                    // 反射机制调用目标对象的方法
                    Object invoke = method.invoke(target, args);

                    System.out.println("jdk代理提交……");

                    return invoke;
                });

        // new InvocationHandler() {
        //     @Override
        //     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //         System.out.println("jdk代理开始……");
        //         // 反射机制调用目标对象的方法
        //         Object invoke = method.invoke(target, args);
        //         return invoke;
        //     }
        // });

        return o;
    }

}
```

client：

```java
package indi.exer.yuluo.Design.proxy.dynamicProxy;

/**
 * @Author: yuluo
 * @CreateTime: 2022-08-09  09:06
 * @Description: TODO
 */

public class client {

    public static void main(String[] args) {
        // 创建目标对象
        TeacherDao teacherDao = new TeacherDao();

        // 给目标对象，创建代理对象
        ITeacherDao prosyInstances = (ITeacherDao) new ProxyFactory(teacherDao).getProsyInstances();

        // 代理对象prosyInstances: class com.sun.proxy.$Proxy0
        System.out.println("代理对象prosyInstances: " + prosyInstances.getClass());

        prosyInstances.teach();
    }

}
```

#### Cglib代理

> 静态代理和jdk代理模式都要求目标对象实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可以使用目标对象子类来实现代理。也叫做子类代理
>
> 在AOP编程中如何选择代理模式：
>
> - 目标对象需要实现接口，使用jdk代理
> - 不需要实现接口，使用Cglib代理
>
> Cglib的底层是使用字节码处理矿建ASM来转换字节码并生成新的类

实现步骤【注意事项】：

- 在内存中动态构建子类，代理的类不能使用final修饰，否则报错ILLegralArgumentException

- 目标对象的方法如果为final/staic，那么就不会被拦截，既不会执行目标对象的额外业务方法。

![image-20220809094210796](.\设计模式.assets\image-20220809094210796.png)

#### 几种代理的变体

![image-20220809094359665](.\设计模式.assets\image-20220809094359665.png)

### 外观模式【Facede】

> 1. 也叫过程模式，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
>
> 2. 通过定义一个一致的接口（界面类），用以屏蔽内部子系统的细节，使得调用端只跟这个接口发生调用，而无需关心这个子系统的内部细节

将所有的子系统通过构造器的方式注入到Facade中，通过外观类进行统一管理。屏蔽子系统的实现细节，子系统对象通过单例模式获得。

应用：mybatis源码：mybatis中的Configuration【Facade类】创建MetaObject，使用到了外观模式

![image-20220808092651338](.\设计模式.assets\image-20220808092651338.png)

注意事项：

> 降低了客户端对子系统使用的复杂性
>
> 通过合理的使用外观模式，可以帮我们更好的划分访问的层次
>
> 当系统需要进行分层设计时，可以考虑使用Facade模式

### 享元模式【Flyweight】

> 也叫蝇量模式， 云哥用共享技术有效地支持大量细粒度的对象
>
> 常用于系统底层开发，解决系统的性能问题，像数据库连接池……
>
> 能够解决重复对象的内存浪费问题，当系统中有大量的相似对象时，需要缓冲池时，不需要总是创建对象，可以从缓冲池里面拿。
>
> String类，池化技术都是享元设计模式的应用，**享元模式时池技术的重要实现方式**

享元模式提出了两个要求：细粒度和共享对象，这里就涉及到了内部状态和外部状态。将对象的信息分为两个部分：内部状态和外部状态

1. 内部状态指的是对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变
2. 外部状态指对象得以依赖的一个标记，是随环境的变化而改变的，不可共享的状态。

例如：五子棋的颜色是固有的内部信息，下子的位置是外部状态。随棋手下子的位置改变

jdk中的Integer用到了享元模式，

![image-20220808095318617](.\设计模式.assets\image-20220808095318617.png)

![image-20220808095604271](.\设计模式.assets\image-20220808095604271.png)

Integer.valueof中的值如果在-128~127的范围内，返回的是从缓冲池中拿到的实例，如果超出则会返回一个新的Integer对象。

## 行为型设计模式

### 模板方法设计模式

基本介绍：

> 模板方法模式，又叫做模板模式，在一个抽象类公开定义执行它的方法的模板。子类可以按照需要重写方法实现，但调用将以抽象类中定义的方式进行
>
> 简单说，模板方法模式定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重新定义该算法的某些特定步骤
>
> 模板方法乐意做成final，不让子类去覆盖

模板方法中的钩子：

我们可以定义一个方法，默认不做任何事情，子类可以视情况要不要覆盖，该方法称为钩子

spring IOC源码

![image-20220810105014017](.\设计模式.assets\image-20220810105014017.png)

注意事项：

![image-20220810105050915](.\设计模式.assets\image-20220810105050915.png)

### 命令模式【Command Pattern】

> 命令模式：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道被请求的操作是那个。只需要在程序运行时指定具体的请求接受者即可，此时，我们可以用命令模式来设计。
>
> 命令模式使得请求发送方与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦
>
> 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（既命名），同时命令模式也可撤销操作
>
> 通俗理解就是：将军发布命令，士兵去执行。将军【Invoker命令发布者】，士兵【Receiver命令执行者】，命令【Command连接将军和士兵】

![image-20220811151700755](.\设计模式.assets\image-20220811151700755.png)

在spring框架中的JdbcTemplate使用到，和命令模式有点差别。

注意事项和细节：

1. 容易设计一个命令队列，把命令对象放到列队，就可以多线程的执行命令，
2. 不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度。

### 访问者模式【Visitor Pattern】

> - 封装一些作用于某种数据结构的各个元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的新操作
> - 主要将数据结构与数据操作分离，解决数据结构和操作耦合性的问题
> - 基本工作原理是：在被访问的类里面加入一个对外提供接待访问者的接口

![image-20220811153723070](.\设计模式.assets\image-20220811153723070.png)

![image-20220811154132164](.\设计模式.assets\image-20220811154132164.png)

注意事项：

- 优点：

  访问者模式符合单一职责原则，让程序具有优秀的扩展性。灵活性非常高

  访问者模式可以对功能进行统一，可以做报表，UI，拦截器与过滤器，适用于数据结构相对稳定的系统

- 缺点：

  违背了依赖倒转原则，依赖的是具体元素不是抽象元素

  违背了迪米特法则，关注了其他类的内部细节

### 迭代器模式

如果集合内的元素是用不同的方式实现的，有数组，还有java的集合类，或者其他的组合方式，当客户端需要遍历的时候，就要使用多种遍历方式，而且还会暴露元素的内部结构，此时就可以考虑使用迭代器模式解决

迭代器模式提供一种遍历元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示。即不需要暴露内部的数据结构

![image-20220812205017589](.\设计模式.assets\image-20220812205017589.png)

![image-20220812205000914](.\设计模式.assets\image-20220812205000914.png)

注意事项和细节：

![image-20220812210205588](.\设计模式.assets\image-20220812210205588.png)

### 观察者模式

原理：

> 对象之间多对一依赖的一种设计方案，被依赖的对象为Subject，依赖的对象是Observer，Subject通知Observer变化。

### 中介者模式【Mediator Pattern】

基本介绍：

> 中介者模式，用一个中介对象封装一系列的对象交互，中介者使得各个对象不需要显式的相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互
>
> 比如MVC设计模式，C（controller）是M（model）和V（view）的中介者，在前后端交互时起到了中间人的作用

注意事项和细节问题

> 多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离成为星型结构
>
> 减少类之间的依赖，降低了耦合，符合迪米特法则
>
> 中介者承担了较多的责任，一旦中介者出了问题，整个系统都会收到影响
>
> 设计不当时，中介者对象本身就会变得过于复杂

### 备忘录模式

基本介绍：

> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态

![image-20220818155220557](.\设计模式.assets\image-20220818155220557.png)

### 解释器模式（Interpreter模式）

基本介绍：

> 是指给定一个语言（表达式），定义它的文法的一种表示，，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）
>
> 应用场景：
>
> - 将一个需要解释执行的语言中的句子表示为一个抽象语法树
> - 一些重复出现的问题可以用一种简单的语言来表达
> - 一个简单语法需要解释的场景
>
> 例子：编译器、运算表达式计算、正则表达式、机器人等

注意事项和细节：

> ![image-20220819151001185](.\设计模式.assets\image-20220819151001185.png)

### 状态模式

基本介绍：

> 主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题、状态和行为是一一对应的，状态之间可以相互转换
>
> 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类

注意事项和细节

> ![image-20220819153734950](.\设计模式.assets\image-20220819153734950.png)

### 策略模式

基本介绍：

> 策略模式中给，定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
>
> 体现了几个设计原则。第一，把变化的代码从不变的代码中分离出来，第二，针对接口编程而不是具体类（定义了策略接口）第三，多用组合/聚合少用继承，（客户通过组合方式使用策略）

在JDK的Arrays的Comparator中使用了策略模式

### 职责链模式（Chain Of Responsibility Pattern 又叫责任链模式）

简单介绍：

> 为请求创建了一个接收者对象的链。对请求的发送者和接收者进行解耦
>
> 通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，就会把请求传递给下一个接收者，依次类推

在Spring-mvc的HandleExecutionChain

spring-mvc的请求流程：

![image-20220821154845128](.\设计模式.assets\image-20220821154845128.png)

注意事项和细节：

![image-20220821154946372](.\设计模式.assets\image-20220821154946372.png)
